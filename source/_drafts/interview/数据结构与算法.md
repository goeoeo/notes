
# 摘录自
数据结构和算法（Golang实现）  
https://www.bookstack.cn/books/hunterhug-goa.c

# 基础知识
## 什么是数据结构
大多数算法都需要组织数据，所以产生了数据结构。数据结构在计算机中，主要是用来实现各种算法的基础，当然数据结构本身也是算法的一部分。  
## 基本的数据结构有：链表，栈和队列，树和图。  
* 链表，就是把数据链接起来，关联起来，一个数据节点指向另外一个数据节点，像自然界的一条条铁链，大部分数据结构，都是由链表的若干变种来表示
* 栈和队列，主要用来存储多个数据，只不过一个是先进后出，一个先进先出。比如下压栈，先入栈的数据是最后才能出来，而我们熟知的队列，先排队的人肯定先获得服务。
* 其次是树和图，树就是有一个树根节点，存放着数据，下面有很多子节点，也存放着数据，类比自然界的树。图则可以类比自然界的地图，多个点指向多个点，点和点之间有一条或多条边，而这些点存放着数据，边也可以存放着数据，比如距离等。


## 分治法和递归
分治法一般使用递归来求问题的解。
理论上，所有的递归方式都可以转化为非递归的方式，只不过使用递归，代码的可读性更高。

### 递归
递归就是不断地调用函数本身。
如果递归式使用了运算符，每次重复的调用都使得运算的链条不断加长，系统不得不使用栈进行数据保存和恢复。
### 尾部递归
尾部递归是指递归函数在调用自身后直接传回其值，而不对其再加运算，效率将会极大的提高。

### 例子1 求阶乘 1*2*3*4..*N

#### 递归解法
```
func Rescuvie(n int)int{
    if n==1{
        return 1
    }

    return n*Rescuvie(n-1)
}
```
#### 尾递归解法
```
func Rescuvie(n int,a int)int{
    if n==1{
        return a
    }

    return Rescuvie(n-1,n*a)
}
```

### 例子2 斐波那契数列
斐波那契数列是指，后一个数是前两个数的和的一种数列
#### 递归
```
func fibonacci(num int) int{
	if num<2{
		return 1
	}
	
	return fibonacci(num-1) + fibonacci(num-2)
}
```
#### 尾部递归
```
func fibonacci(n int,a1,a2 int){
    if n==0 {
        return a1
    }

    return fibonacci(n-1,a2,a1+a2)
}
```
#### 斐波那契数列 不使用递归的解法，闭包
```
func fibonacci() func() int{
	a, b := 0, 1
	return func() int{
		a, b = b, a+b
		return a
	}
}
```

### 例子3 二分查找
在一个已经排好序的数列，找出某个数
```
func BinarySearch(array []int, target int, l, r int) int {
    if l > r {
        // 出界了，找不到
        return -1
    }
    // 从中间开始找
    mid := (l + r) / 2
    middleNum := array[mid]
    if middleNum == target {
        return mid // 找到了
    } else if middleNum > target {
        // 中间的数比目标还大，从左边找
        return BinarySearch(array, target, 1, mid-1)
    } else {
        // 中间的数比目标还小，从右边找
        return BinarySearch(array, target, mid+1, r)
    }
}
```


## 算法复杂度及渐进符号
复杂度有两个维度：时间和空间。

###　算法规模
算法的优先级排列如下，一般排在上面的要优于排在下面的：　　
1.常数复杂度：O(1)  
2.对数复杂度：O(logn)  
3.一次方复杂度：O(n)  
4.一次方乘对数复杂度：O(nlogn)  
5.乘方复杂度：O(n^2)，O(n^3)  
6.指数复杂度：O(2^n)  
7.阶乘复杂度：O(n!)  
8.无限大指数复杂度：O(n^n)  