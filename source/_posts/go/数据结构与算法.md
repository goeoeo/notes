
# 摘录自
数据结构和算法（Golang实现）  
https://www.bookstack.cn/books/hunterhug-goa.c

# 基础知识
## 什么是数据结构
大多数算法都需要组织数据，所以产生了数据结构。数据结构在计算机中，主要是用来实现各种算法的基础，当然数据结构本身也是算法的一部分。  
## 基本的数据结构有：链表，栈和队列，树和图。  
* 链表，就是把数据链接起来，关联起来，一个数据节点指向另外一个数据节点，像自然界的一条条铁链，大部分数据结构，都是由链表的若干变种来表示
* 栈和队列，主要用来存储多个数据，只不过一个是先进后出，一个先进先出。比如下压栈，先入栈的数据是最后才能出来，而我们熟知的队列，先排队的人肯定先获得服务。
* 其次是树和图，树就是有一个树根节点，存放着数据，下面有很多子节点，也存放着数据，类比自然界的树。图则可以类比自然界的地图，多个点指向多个点，点和点之间有一条或多条边，而这些点存放着数据，边也可以存放着数据，比如距离等。


## 分治法和递归
分治法一般使用递归来求问题的解。
理论上，所有的递归方式都可以转化为非递归的方式，只不过使用递归，代码的可读性更高。

### 递归
递归就是不断地调用函数本身。
如果递归式使用了运算符，每次重复的调用都使得运算的链条不断加长，系统不得不使用栈进行数据保存和恢复。
### 尾部递归
尾部递归是指递归函数在调用自身后直接传回其值，而不对其再加运算，效率将会极大的提高。

### 例子1 求阶乘 1*2*3*4..*N

#### 递归解法
```
func Rescuvie(n int)int{
    if n==1{
        return 1
    }

    return n*Rescuvie(n-1)
}
```
#### 尾递归解法
```
func Rescuvie(n int,a int)int{
    if n==1{
        return a
    }

    return Rescuvie(n-1,n*a)
}
```

### 例子2 斐波那契数列
斐波那契数列是指，后一个数是前两个数的和的一种数列
#### 递归
```
func fibonacci(num int) int{
	if num<2{
		return 1
	}
	
	return fibonacci(num-1) + fibonacci(num-2)
}
```
#### 尾部递归
```
func fibonacci(n int,a1,a2 int){
    if n==0 {
        return a1
    }

    return fibonacci(n-1,a2,a1+a2)
}
```
#### 斐波那契数列 不使用递归的解法，闭包
```
func fibonacci() func() int{
	a, b := 0, 1
	return func() int{
		a, b = b, a+b
		return a
	}
}
```

### 例子3 二分查找
在一个已经排好序的数列，找出某个数
```
func BinarySearch(array []int, target int, l, r int) int {
    if l > r {
        // 出界了，找不到
        return -1
    }
    // 从中间开始找
    mid := (l + r) / 2
    middleNum := array[mid]
    if middleNum == target {
        return mid // 找到了
    } else if middleNum > target {
        // 中间的数比目标还大，从左边找
        return BinarySearch(array, target, 1, mid-1)
    } else {
        // 中间的数比目标还小，从右边找
        return BinarySearch(array, target, mid+1, r)
    }
}
```


## 算法复杂度及渐进符号
复杂度有两个维度：时间和空间。

###　算法规模
算法的优先级排列如下，一般排在上面的要优于排在下面的：　　
1.常数复杂度：O(1)  
2.对数复杂度：O(logn)  
3.一次方复杂度：O(n)  
4.一次方乘对数复杂度：O(nlogn)  
5.乘方复杂度：O(n^2)，O(n^3)  
6.指数复杂度：O(2^n)  
7.阶乘复杂度：O(n!)  
8.无限大指数复杂度：O(n^n)  

## 常见数据结构和算法
1. 排序算法  
2. 查找算法  
3. 图相关算法
4. 其他算法

### 链表
链表由一个个数据节点组成的，它是一个递归结构，要么它是空的，要么它存在一个指向另外一个数据节点的引用。  
简单来说，链表就是将一个数据与另一个数据关联起来的结构  
* 单链表，就是链表是单向的，像我们上面这个结构一样，可以一直往下找到下一个数据节点，它只有一个方向，它不能往回找
* 双链表，每个节点既可以找到它之前的节点，也可以找到之后的节点，是双向的。
* 循环链表，就是它一直往下找数据节点，最后回到了自己那个节点，形成了一个回路。循环单链表和循环双链表的区别就是，一个只能一个方向走，一个两个方向都可以走。


#### 数组和链表
数组和链表是两个不同的概念。一个是编程语言提供的基本数据类型，表示一个连续的内存空间，可通过一个索引访问数据。另一个是我们定义的数据结构，通过一个数据节点，可以定位到另一个数据节点，不要求连续的内存空间。 
数组的优点是占用空间小，查询快，直接使用索引就可以获取数据元素，缺点是移动和删除数据元素要大量移动空间。  
链表的优点是移动和删除数据元素速度快，只要把相关的数据元素重新链接起来，但缺点是占用空间大，查找需要遍历。  
链表 和 数组 可以用来辅助构建各种基本数据结构。  

### 可变长数组
可变长数组在实际开发上，经常会使用到，其在固定大小数组的基础上，会自动进行容量扩展。  
Golang 自动提供了这一数据类型：切片（可变长数组）  

### 栈和队列
* 栈：先进后出，先进队的数据最后才出来。
* 队列：先进先出，先进队的数据先出来。

### 列表
列表 List：存放数据，数据按顺序排列，可以依次入队和出队，有序号关系，可以取出某序号的数据。  
队列 (queue) 和先进后出的 栈（stack） 都是列表  
线性表 也是列表的意思，示具有相同特性的数据元素的有限序列


### 字典
字典是存储键值对的数据结构，把一个键和一个值映射起来，一一映射，键不能重复。  
字典的实现有两种方式：哈希表 HashTable 和红黑树 RBTree。Golang 语言中字典 map 的实现由哈希表实现  

### 树
树是一种比较高级的基础数据结构，由 n 个有限节点组成的具有层次关系的集合。

#### 树的定义  
1. 有节点间的层次关系，分为父节点和子节点。
2. 有唯一一个根节点，该根节点没有父节点。
3. 除了根节点，每个节点有且只有一个父节点。
4. 每一个节点本身以及它的后代也是一棵树，是一个递归的结构。
5. 没有后代的节点称为叶子节点，没有节点的树称为空树。


#### 二叉树的数学特征
1. 高度为 h≥0 的二叉树至少有 h+1 个结点，比如最不平衡的二叉树就是退化的线性链表结构，所有的节点都只有左儿子节点，或者所有的节点都只有右儿子节点。
2. 高度为 h≥0 的二叉树至多有 2^h+1 个节点，比如这棵树是满二叉树。
3. 含有 n≥1 个结点的二叉树的高度至多为 n-1，由 1 退化的线性链表可以反推。
4. 含有 n≥1 个结点的二叉树的高度至少为 logn，由 2 满二叉树可以反推。
5. 在二叉树的第 i 层，至多有 2^(i-1) 个节点，比如该层是满的。



#### 四种遍历方法
1. 先序遍历：先访问根节点，再访问左子树，最后访问右子树。
2. 后序遍历：先访问左子树，再访问右子树，最后访问根节点。
3. 中序遍历：先访问左子树，再访问根节点，最后访问右子树。
4. 层次遍历：每一层从左到右访问每一个节点。

### 排序算法
快速排序，归并排序和堆排序是比较高级的排序算法。  
目前被认为综合最好的高级排序算法是快速排序，快速排序的平均用时最短，大多数的编程库内置的排序算法都是它。  
![](数据结构与算法/sort.png)

在 sort.go文件中，排序算法有: 插入排序(insertionSort)、堆排序(heapSort)，快速排序(quickSort)、希尔排序(ShellSort)、归并排序(SymMerge)。 这些函数都是以小写字母开头，意味着他们对外是不可见的(letter case set visibility)。其中，归并排序用于 Stable函数，其余算法用于 Sort函数。
#### 冒泡排序
从第一个数开始，依次比较相邻的两个数，如果前面一个数比后面一个数大，那么交换位置，直到处理到最后一个数，最后的这个数是最大的。 
```
package main
import "fmt"
func BubbleSort(list []int) {
    n := len(list)
    // 在一轮中有没有交换过
    didSwap := false
    // 进行 N-1 轮迭代
    for i := n - 1; i > 0; i-- {
        // 每次从第一位开始比较，比较到第 i 位就不比较了，因为前一轮该位已经有序了
        for j := 0; j < i; j++ {
            // 如果前面的数比后面的大，那么交换
            if list[j] > list[j+1] {
                list[j], list[j+1] = list[j+1], list[j]
                didSwap = true
            }
        }
        // 如果在一轮中没有交换过，那么已经排好序了，直接返回
        if !didSwap {
            return
        }
    }
}
func main() {
    list := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3}
    BubbleSort(list)
    fmt.Println(list)
}
```
#### 选择排序
选择排序，一般我们指的是简单选择排序，也可以叫直接选择排序，它不像冒泡排序一样相邻地交换元素，而是通过选择最小的元素，每轮迭代只需交换一次。虽然交换次数比冒泡少很多，但效率和冒泡排序一样的糟糕。  

改进：我们每一轮，除了找最小数之外，还找最大数，然后分别和前面和后面的元素交换，这样循环次数减少一半

#### 插入排序、希尔排序
一般建议待排序数组为小规模情况下使用直接插入排序，在规模中等的情况下可以使用希尔排序，但在大规模还是要使用快速排序，归并排序或堆排序。


#### 归并排序
归并排序是一种分治策略的排序算法。它是一种比较特殊的排序算法，通过递归地先使每个子序列有序，再将两个有序的序列进行合并成一个有序的序列。  
> 归并排序首先由著名的现代计算机之父 冯·诺依曼 在 1945 年发明
##### 自顶向下归并排序
使用递归实现，时间复杂度为：O(nlogn)。 空间复杂度为：O(logn)

##### 自底向上归并排序
不使用递归，时间复杂度为：O(nlogn)。 空间复杂度为：O(1)

#### 优先队列及堆排序
优先队列是一种能完成以下任务的队列：插入一个数值，取出最小或最大的数值（获取数值，并且删除）。
优先队列可以用二叉树来实现，我们称这种结构为二叉堆。

#### 快速排序
快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 
快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了  
![](数据结构与算法/快速排序.png)

#### 内置库使用快速排序的原因
首先堆排序，归并排序最好最坏时间复杂度都是：O(nlogn)，而快速排序最坏的时间复杂度是：O(n^2)，但是很多编程语言内置的排序算法使用的仍然是快速排序，这是为什么？

1. 这个问题有偏颇，选择排序算法要看具体的场景，Linux 内核用的排序算法就是堆排序，而 Java 对于数量比较多的复杂对象排序，内置排序使用的是归并排序，只是一般情况下，快速排序更快。
2. 归并排序有两个稳定，第一个稳定是排序前后相同的元素位置不变，第二个稳定是，每次都是很平均地进行排序，读取数据也是顺序读取，能够利用存储器缓存的特征，比如从磁盘读取数据进行排序。因为排序过程需要占用额外的辅助数组空间，所以这部分有代价损耗，但是原地手摇的归并排序克服了这个缺陷。
3. 复杂度中，大 O 有一个常数项被省略了，堆排序每次取最大的值之后，都需要进行节点翻转，重新恢复堆的特征，做了大量无用功，常数项比快速排序大，大部分情况下比快速排序慢很多。但是堆排序时间较稳定，不会出现快排最坏 O(n^2) 的情况，且省空间，不需要额外的存储空间和栈空间。
4. 当待排序数量大于16000个元素时，使用自底向上的堆排序比快速排序还快可见此：https://core.ac.uk/download/pdf/82350265.pdf。
5. 快速排序最坏情况下复杂度高，主要在于切分不像归并排序一样平均，而是很依赖基准数的现在，我们通过改进，比如随机数，三切分等，这种最坏情况的概率极大的降低。大多数情况下，它并不会那么地坏，大多数快才是真的块。
6. 归并排序和快速排序都是分治法，排序的数据都是相邻的，而堆排序比较的数可能跨越很大的范围，导致局部性命中率降低，不能利用现代存储器缓存的特征，加载数据过程会损失性能。

对稳定性有要求的，要求排序前后相同元素位置不变，可以使用归并排序，Java 中的复杂对象类型，要求排序前后位置不能发生变化，所以小规模数据下使用了直接插入排序，大规模数据下使用了归并排序。

对栈，存储空间有要求的可以使用堆排序，比如 Linux 内核栈小，快速排序占用程序栈太大了，使用快速排序可能栈溢出，所以使用了堆排序。

#### golang 标准库sort排序
##### sort.SliceStable
会先按照 20 个元素的范围，对整个切片分段进行插入排序，因为小数组插入排序效率高，然后再对这些已排好序的小数组进行归并排序。其中归并排序还使用了原地排序，节约了辅助空间。
##### sort.Slice
快速排序限制程序栈的层数为： 2*ceil(log(n+1))，当递归超过该层时表示程序栈过深，那么转为堆排序。
上述快速排序还使用了三种优化，第一种是递归时小数组转为插入排序，第二种是使用了中位数基准数，第三种使用了三切分。


### 查找算法
1. 散列查找：也称哈希查找，有拉链法查找，也有线性探测法查找，拉链法使用数组链表结构，线性探测法使用数组。
2. 树查找：有搜索二叉树，平衡查找树如：红黑树，B树，AVL树，B+等，使用链表树结构。

#### 哈希表：散列查找
* 线性探测法
* 拉链法
### 二叉查找树
二叉查找树，又叫二叉排序树，二叉搜索树，是一种有特定规则的二叉树  
1. 它是一棵二叉树，或者是空树。
2. 左子树所有节点的值都小于它的根节点，右子树所有节点的值都大于它的根节点。
3. 左右子树也是一棵二叉查找树。
二叉查找树的特点是，一直往左儿子往下找左儿子，可以找到最小的元素，一直往右儿子找右儿子，可以找到最大的元素。

