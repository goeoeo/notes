---
categories:
- go
---

# 字符串

字符串结构: 指向数据地址的指针(8字节)+字符串长度变量(8字节)

1.string 不可修改,因为在字符串会被分配到只读内存段。  
2.将字符串转换为slice([]byte) ,是重新分配了内存，不会修改原有字符串。  
3.使用unsafe包 将slice 指向原字符串的内存，也不能修改，强制修改会包 panic

<!--more-->
# slice

slice结构: 指向数据地址的指针(8字节)+len当前slice长度(8字节)+cap 底层数组的长度(8字节)

## slice 扩容规则

step1: 预估扩容后的容量

1. 预估容量*2 < cap ->newCap=cap
2. 如果oldLen < 1024 -> newCap=oldCap*2 ,否则 newCap=oldCap*1.25

> golang1.16.5 后 是oldCap < 1024 -> newCap=oldCap*2 ,否则 newCap=oldCap*1.25 step2: newCap个元素需要多大的内存   
内存= 预估容量* 元素类型大小

step3: 匹配到合适的内存规格

# 内存对齐

## 为什么要内存对齐？

cpu为了快速读取内容，

## 什么是内存对齐 ？

为保证程序顺利高效的运行，编译器会把各种类型的数据安排到合适的地址，并占用合适的长度，这就是内存对齐 。 每种类型的对齐值，就是他的对齐边界

内存对齐要求数据存储地址，以及占用的字节数都要是他对齐边界的倍数

## 平台对应的最大对齐边界

寄存器宽度、机器字长  
数据类型的对齐边界为与平台最大对齐边界取较小的那个。

## 结构体占用字节数?

结构体字节数需要是对齐边界的倍数，因为要考虑数组。只有每个结构体的大小是对齐值的整数倍，才能保证数组里面每个类型都是内存对齐的。

# Map

键值对的存储一般都会使用hash表   
哈希表通常会有一堆桶（buckets）来存储键值对，通过哈希函数将键值对的键处理成键hash值，利用hash值来选择桶

## 选桶算法(m为桶的数量)：

1. 取模法 hash%m
2. 与运算 hash&(m-1)

> golang 使用的与运算法。

## hash冲突

两个key通过hash函数算出的hash值相同  
解决hash冲突的办法

1. 开放地址法，将冲突的hash放到下一个的桶中寻找，当桶找不到则到下一个桶中寻找，直到遇到空桶
2. 拉链法，编号为2的桶被占用了，在2后面链一个新桶，当前桶找不到，去链接的桶里面寻找。  
   hash的发送会影响哈希表的读写效率，选择散列均匀的hash函数可以减少hash冲突的发生，适时的对哈希表进行扩容也是保证读写效率的有效手段

## hash扩容

通常会吧存储键值对的数据与桶数目的比值作为是否需要扩容的判断依据，这个比值叫**负载因子(LoadFactor)**  
数据迁移，把旧桶里存储的键值对都迁移到新桶里。如果哈希表存储的键值对较多，一次性迁移所有桶花费的时间比较显著，所以通常会在哈希表扩容时，先分配足够多的新桶 然后用一个字段记录旧桶的位置，再增加一个字段记录旧桶迁移的进度(
如记录下一个需要迁移的旧桶编号)，如果hash表每次在进行读写操作时，如果检测到当前处于扩容阶段
就完成一部分键值对迁移任务，直到所有的旧桶迁移完成，旧桶不在使用，才算真正完成一次哈希表的扩容，像这样把键值对迁移的时间分摊到多次哈希表操作的方式，叫做渐进式扩容。  
渐进式扩容，可以避免一次性扩容的瞬时抖动。

## go语言中Map类型的底层实现就是哈希表

Map 类型的变量本质上是一个指针, 指向hmap  
一个桶里可以放8个键值对，但是为了让内存更加紧凑，8个key放一起，8个value放一起，在8个key前面是8个tophash  
每个tophash都是对应hash值的高8位 ,overflow 存的是溢出桶   
实际上如果哈希表要分配桶的数据大于2^4次方，就会认为使用溢出桶的几率比较大，就会预分配2^(B-4)个溢出桶备用
![](go硬核干货/bmap.png)

```go
package Map

import "unsafe"

//Map 底层结构体
type hmap struct {
	count      int //键值对数目
	flags      uint8
	B          uint8  //B 记录桶的数目的幂，桶数=2^B，因为选择桶用的是与运算的方法
	noverflow  uint16 //使用溢出桶的数量
	hash0      uint32
	buckets    unsafe.Pointer //当前桶
	oldbuckets unsafe.Pointer //旧桶
	nevacuate  uintptr        //渐进式扩容阶段，即将迁移的旧桶编号
	extra      *mapextra
}

//记录溢出桶的相关信息
type mapextra struct {
	overflow     unsafe.Pointer //已经使用的溢出桶
	oldoverflow  unsafe.Pointer //用于在扩容阶段存储旧通用到的那些溢出桶的地址
	nextoverflow unsafe.Pointer //下一个空闲溢出桶
}

//桶
type bmap struct {
}

```

## go Map的扩容规则

* count/(2^5) > 6.5 => 翻倍扩容
* LoadFactor没有超标并且noverflow 较多 => 等量扩容

> noverflow较多的情况:  
> 1.B<=15,noverflow>2^B  
> 2.B>15,noverflow>2^15

### 等量扩容
创建与原来相同数量的桶  
为什么要进行等量扩容？  
在溢出桶使用较多，负载因子较低的时候，说明删除了大量的键。通过等量扩容，减少溢出桶的使用。

# Context

一个接口，四种实现，六个函数
