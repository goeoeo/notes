---
categories:

- go

---

# 字符串

字符串结构: 指向数据地址的指针(8字节)+字符串长度变量(8字节)

1.string 不可修改,因为在字符串会被分配到只读内存段。  
2.将字符串转换为slice([]byte) ,是重新分配了内存，不会修改原有字符串。  
3.使用unsafe包 将slice 指向原字符串的内存，也不能修改，强制修改会包 panic

<!--more-->

# slice

slice结构: 指向数据地址的指针(8字节)+len当前slice长度(8字节)+cap 底层数组的长度(8字节)

## slice 扩容规则

step1: 预估扩容后的容量

1. 预估容量*2 < cap ->newCap=cap
2. 如果oldLen < 1024 -> newCap=oldCap*2 ,否则 newCap=oldCap*1.25

> golang1.16.5 后 是oldCap < 1024 -> newCap=oldCap*2 ,否则 newCap=oldCap*1.25 step2: newCap个元素需要多大的内存   
内存= 预估容量* 元素类型大小

step3: 匹配到合适的内存规格

# 内存对齐

## 为什么要内存对齐？

cpu为了快速读取内容，

## 什么是内存对齐 ？

为保证程序顺利高效的运行，编译器会把各种类型的数据安排到合适的地址，并占用合适的长度，这就是内存对齐 。 每种类型的对齐值，就是他的对齐边界

内存对齐要求数据存储地址，以及占用的字节数都要是他对齐边界的倍数

## 平台对应的最大对齐边界

寄存器宽度、机器字长  
数据类型的对齐边界为与平台最大对齐边界取较小的那个。

## 结构体占用字节数?

结构体字节数需要是对齐边界的倍数，因为要考虑数组。只有每个结构体的大小是对齐值的整数倍，才能保证数组里面每个类型都是内存对齐的。

# Map

键值对的存储一般都会使用hash表   
哈希表通常会有一堆桶（buckets）来存储键值对，通过哈希函数将键值对的键处理成键hash值，利用hash值来选择桶

## 选桶算法(m为桶的数量)：

1. 取模法 hash%m
2. 与运算 hash&(m-1)

> golang 使用的与运算法。

## hash冲突

两个key通过hash函数算出的hash值相同  
解决hash冲突的办法

1. 开放地址法，将冲突的hash放到下一个的桶中寻找，当桶找不到则到下一个桶中寻找，直到遇到空桶
2. 拉链法，编号为2的桶被占用了，在2后面链一个新桶，当前桶找不到，去链接的桶里面寻找。  
   hash的发送会影响哈希表的读写效率，选择散列均匀的hash函数可以减少hash冲突的发生，适时的对哈希表进行扩容也是保证读写效率的有效手段

## hash扩容

通常会吧存储键值对的数据与桶数目的比值作为是否需要扩容的判断依据，这个比值叫**负载因子(LoadFactor)**  
数据迁移，把旧桶里存储的键值对都迁移到新桶里。如果哈希表存储的键值对较多，一次性迁移所有桶花费的时间比较显著，所以通常会在哈希表扩容时，先分配足够多的新桶 然后用一个字段记录旧桶的位置，再增加一个字段记录旧桶迁移的进度(
如记录下一个需要迁移的旧桶编号)，如果hash表每次在进行读写操作时，如果检测到当前处于扩容阶段
就完成一部分键值对迁移任务，直到所有的旧桶迁移完成，旧桶不在使用，才算真正完成一次哈希表的扩容，像这样把键值对迁移的时间分摊到多次哈希表操作的方式，叫做渐进式扩容。  
渐进式扩容，可以避免一次性扩容的瞬时抖动。

## go语言中Map类型的底层实现就是哈希表

Map 类型的变量本质上是一个指针, 指向hmap  
一个桶里可以放8个键值对，但是为了让内存更加紧凑，8个key放一起，8个value放一起，在8个key前面是8个tophash  
每个tophash都是对应hash值的高8位 ,overflow 存的是溢出桶   
实际上如果哈希表要分配桶的数据大于2^4次方，就会认为使用溢出桶的几率比较大，就会预分配2^(B-4)个溢出桶备用
![](go硬核干货/bmap.png)

```go
package Map

import "unsafe"

//Map 底层结构体
type hmap struct {
	count      int //键值对数目
	flags      uint8
	B          uint8  //B 记录桶的数目的幂，桶数=2^B，因为选择桶用的是与运算的方法
	noverflow  uint16 //使用溢出桶的数量
	hash0      uint32
	buckets    unsafe.Pointer //当前桶
	oldbuckets unsafe.Pointer //旧桶
	nevacuate  uintptr        //渐进式扩容阶段，即将迁移的旧桶编号
	extra      *mapextra
}

//记录溢出桶的相关信息
type mapextra struct {
	overflow     unsafe.Pointer //已经使用的溢出桶
	oldoverflow  unsafe.Pointer //用于在扩容阶段存储旧通用到的那些溢出桶的地址
	nextoverflow unsafe.Pointer //下一个空闲溢出桶
}

//桶
type bmap struct {
}

```

## go Map的扩容规则

* count/(2^5) > 6.5 => 翻倍扩容
* LoadFactor没有超标并且noverflow 较多 => 等量扩容

> noverflow较多的情况:  
> 1.B<=15,noverflow>2^B  
> 2.B>15,noverflow>2^15

### 等量扩容

创建与原来相同数量的桶  
为什么要进行等量扩容？  
在溢出桶使用较多，负载因子较低的时候，说明删除了大量的键。通过等量扩容，减少溢出桶的使用。

# 函数调用栈

我们按照编程语言的语法定义的函数，会被编译器编译成一堆堆的机器指令，写入可执行文件。  
执行时，可以执行文件被加载到内存中，这些机器指令，对应虚拟地址空间中位于代码段。如果在一个函数中调用另外一个函数，编译器就会生成一条call指令。  
程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条ret指令，负责在函数结束后，调回到调用处，继续执行。  
函数执行时，需要有足够的内存空间，供它存放局部变量、参数等数据，这段空间对应到虚拟地址空间的栈，栈只有一个口可以出，先入后出规则  
运行时，栈上面是高地址，向下增长，分配给函数的栈空间称为函数栈帧（stack frame），函数栈帧由栈底（bp 栈基）到栈顶（sp 栈指针）

**go 语言中函数栈帧布局**   
调用者栈基地址  
局部变量  
调用函数的返回值  
参数

call 指令 只做两件事，第一将下一条指令的地址入栈，这就是返回地址，被调用函数执行结束后会跳回到这里，继续执行。第二跳转到被调用函数的入口
处执行，所有的函数栈帧布局都遵循统一的约定，所以被调用者是通过栈指针加上偏移来定位到每一个参数好返回值的  
程序执行时cpu 用特定的寄存器，来存储运行时 栈基和栈指针，用指令指针寄存器用于存储下一条要执行的指令地址  
go语言中函数栈帧不是逐步扩张的，而是在分配栈帧时，直接将栈指针移动到所需最大栈空间的位置，然后通过栈指针加偏移值，这种相对寻址方式使用函数 栈帧。之所以一次行分配，主要是为了避免发送栈访问越界。

ret 指令 1.弹出返回地址，2.跳转到返回地址。  
每个函数开始时会分配栈帧，结束前又会释放自己的栈帧

## go语言中返回值赋值早于defer函数

```go
package main

import "fmt"

func incr(a int) int {
   var b int
   defer func() {
      a++
      b++
   }()
   a++
   b = a
   return a
}

func main() {
   var a, b int
   b = incr(a)
   fmt.Println(a,b)//0,1
}
```
```go
package main

import "fmt"

func incr(a int) (b int) {
   defer func() {
      a++
      b++
   }()
   a++
   return a
}

func main() {
   var a, b int
   b = incr(a)
   fmt.Println(a,b)//0,2
}
```

## 一个函数中调用了多个函数，且参数和返回值各不相同  
如果一个函数A调用了两个函数B、C ,但是这两个函数的参数和返回值占用的空间并不相同，go语言的函数栈帧是一次性分配的，要
以最大的参数加返回值空间为标准来分配，才能满足所有被调用函数的需求。被调用者通过栈指针相对寻址来定位自己的参数和返回值

# 闭包
go 语言中函数是头等对象，可以作为参数传递，可以作为函数返回值，也可以绑定到变量，Go语言称这样的参数、返回值、或变量为function value，
函数指令在编译起见生成，而function value 本质上是一个指针，但是并不直接指向函数指令入口，而是指向一个runtime.funcval的结构体,这个结
构体里只有一个地址fn，这个地址就是函数指令的入口地址。
```go
package runtime
type funcval struct {
	fn uintptr
}
```
## 为什么需要通过funcval结构体来包装执行函数的地址,然后使用一个二级指针来调用呢？
这里主要是为了处理闭包的情况。  
> 闭包：要包括自由变量（在函数外部定义但在函数内部引用）；脱离了形成闭包的上下文，闭包也能正常使用这些自由变量

![](go硬核干货/img.png)  
函数create 的返回值是一个函数，但这个函数内部使用了外部定义的变量c，即使create执行结束，通过f1，f2也能正常执行这个闭包函数，并使用定义
在create函数内部的局部变量c，所以这里符合闭包的定义，通常称这个变量c为捕获变量。  
闭包函数的指令自然也在编译阶段生成，但因为每个闭包对象都要保存自己的捕获变量，所以要到执行阶段才创建对应的闭包对象。  
到执行阶段，main函数栈帧有两个局部变量，然后是返回值空间，到create函数栈帧这里，有一个局部变量c等于2，create函数会在堆上分配一个fucval
结构体，fn指向闭包函数入口，除此之外还有一个捕获列表，这里只捕获了一个变量c，然后这个结构体的起始地址就作为返回值，写入返回值空间。  
通过f1、f2，对应的闭包函数就会找到各自对应的funcval结构体，拿到同一个函数入口，但是会使用不同的捕获列表，这就是称闭包为有状态函数的原因

## 闭包函数是如何找到对应的捕获列表呢？
go语言中通过一个funcval 调用函数时，会把对应的funcval结构体地址存入特定寄存器，例如amd64平台使用的是dx寄存器，这样在闭包函数中就可以通
过寄存器取出funcval结构体的地址，然后加上响应的偏移来找到每一个被捕获的变量。  
所以go语言中，闭包就是有捕获列表的funcval，而没有捕获列表的funcval，直接忽略这个寄存器的值就好了。  

## 捕获列表
捕获列表 不单单只是拷贝变量值。需要分情况。被闭包捕获的变量，在外层函数与闭包函数中表现一致，好像他们在使用同一个变量，为此go语言的编译器
针对不同情况做了不同的处理

### 情况1 
被捕获的变量除了初始化复制外，在其它任何地方都没有修改过  
直接拷贝值到捕获列表中

### 情况2
局部变量除了初始化赋值外还被修改过。
变量会改为堆分配，捕获列表中存的是变量的地址
> 局部变量堆分配，是变量逃逸的一种场景。

### 情况3
如果修改并被捕获的是参数，涉及到函数原型，就不能像局部变量那样处理了  
参数依然通过调用者栈帧传入，但是编译器会把栈上这个参数拷贝到堆上一份，然后外层函数和闭包函数都使用堆上分配的这一个，

### 情况4
如果被捕获的是返回值  
调用者栈帧上依然会分配返回值空间，不过闭包的外层函数会在堆上也分配一个，外层函数和闭包函数都使用堆上分配的这一个，在外层函数返回前，需要
把堆上的返回值拷贝到栈上的返回值空间

处理方式虽然多样，但目的只有一个，就是保持捕获变量在外层函数与闭包函数的一致性。  

# 方法
如果我们定义一个类型A,并给它定义一个方法Name,然后就可以使用 a.Name 或者 A.Name(a) 来调用Name方法，实际上a.Name是调用语法糖  
![](go硬核干货/img_1.png)  
go语言中 函数只和参数类型与返回值相关，方法就是普通的函数，方法的接受者是隐含的第一个参数

## 方法表达式与方法变量
![](go硬核干货/img_2.png)
方法表达和方法变量 本质上都是一个funcval，方法变量会捕获方法接受者a形成闭包,但这里的f2仅作为局部变量，它与a的生命周期是一致的，所以编译器
会做出优化，把它转换为类型A的方法调用并传入a作为参数 A.Name(a),

# defer
关于defer 我们知道它会在函数返回之前倒叙执行。  
先通过deferproc函数注册defer函数，然后在return之前调用。  
defer信息会注册到一个链表，而当前执行的goroutine持有这个链表的头指针，每个goroutine在执行时都有一个对应的结构体g，其中有一个字段_defer指向
defer链表的头，_defer 链表链起来的是一个一个defer结构体，新注册的defer会添加到链表的头部。执行时也是从头开始，所以defer才会表现为倒叙执行。  

defer 结构体  
![](go硬核干货/img_3.png)

## go1.12defer 的问题
1. _defer在堆上分配 ，即使有预分配的deferpool,也需要去堆上获取与释放，而且参数还要在堆栈间来回拷贝  
2. 使用链表注册defer信息，而链表本身操作比较慢

## go1.13和go1.14对defer的改进
go1.14的defer，通过在编译阶段插入代码, 把defer函数的执行逻辑展开在所属函数内，open code defer，和1.13一样不适用于循环中的defer，循环中
defer，由于在编译阶段无法确定数量，所以只能在堆分配。  
go1.14defer 性能提升了一个数量级，open codeed defer 未注册到defer连表中，所以在发生panic和runtime.Goexit的时候，需要额外进行栈扫描来
执行未注册到链表中的defer。所以panic变慢了。  


# panic和recover
当前执行的goroutine 中有一个defer链表的头指针，同时也有个以panic链表的头指针，panic连起来的是一个个panic结构体，当发生新的panic的时候，
也是在链表的头上插入新的panic结构体。
panic 结构体    
![go硬核干货](go硬核干货/img_4.png)  
panic触发defer执行，最后从连表尾部打印异常信息。  

## panic 两点重要信息
* panic执行defer函数的方式为先标记后释放，目的是为了终止之前发生的panic  
* 所有还在panic链表上的项都会被输出，顺序与panic发生的顺序一致

# 类型系统
方法本质上就是函数，只不过在调用时，接受者会作为第一个参数传入  
在定义方法的时候不能为内置类型和接口定义方法。  
内置类型和自定义类型，都有其对应的描述信息，称为他的“类型元数据”，每种类型元数据都是全局唯一的,这些类型元数据共同构成了go语言的“类型系统”

# 接口
## 空接口 interface{}
![img.png](go硬核干货/img_5.png)  

未被赋值前，_type=nil,data=nil 赋值后，_type指向类型元数据 ，data指向数据

## 非空接口 
一个变量想要赋值给一个非空接口类型，必须要实现这个非空接口类型的所有方法。
![img.png](go硬核干货/img_6.png)    

![img.png](go硬核干货/img_7.png)  
如果我们声明一个io.ReadWriter类型的变量rw,它被赋值以前data=nil,tab=nil,吧一个*os.File的类型变量f 赋值给rw,此时rw的动态值就是f,而tab
会指向一个itab结构体，他的接口类型为io.ReadWriter,动态类型为*os.File ,同时注意itab这里的fun，它会从动态类型元数据中拷贝接口要求的那些
方法的地址，以便通过rw快速定位到方法而无需再去类型元数据那里查找。  

关于itab 还要额外关注一点，一旦接口类型确定了，动态类型确定了，那么itab的内容就不会改变了。那这个itab结构体也就确定了。所以这个itab结构体是可以复用的  
实际上go语言会吧itab结构体缓存起来，并且以接口类型和动态类型的组合为key，以itab结构体指针为value,构造一个hash表，用于存储和查询itab缓存信息，
这里的hash表和map底层的hash表不同，是一种更为简便的设计，需要一个itab结构体是，会首先去这里查找，用接口类型的hash值和动态类型的hash值，进行异或运算得到
key的hash值，如果已经有对应的itab指针就直接拿来使用，如果没有就创建一个itab结构体，然后添加到这个hash表中。

# 类型断言
抽象类型： 空接口、非空接口  
具体类型：int、string、slice、map、struct。。。  
类型断言作用在接口值之上，可以是空接口，也可以是非空接口，断言的目标类型可以是非空接口类型、也可以是具体类型。
* 空接口.(具体类型)
* 非空接口.(具体类型)
* 空接口.(非空接口)
* 非空接口.(非空接口)


# 反射 reflect
runtime包中的空接口和非空接口的类型元数据都是未导出的，所以reflect包中又定义了一套和runtime包中保持一致。  
reflect包提供TypeOf 函数，用于获取变量的类型信息，接受一个空接口类型的参数，并返回一个reflect.Type类型的返回值。  
所有参数为空接口类型的情况，通过传递拷贝后的变量的地址，来实现传值的语义   

通过reflect.ValueOf 来获取值，如果需要修改原变量的值，需要传指针。

# GMP

## golang调度器的由来
### 单进程时代的两个问题
1. 单一执行流程，计算机一个任务一个任务处理
2. 进程阻塞锁带来的CPU浪费时间  

### 多进程、多线程的问题
1. 设计变得复杂
* 进程、线程数量越多，切换成本就越大，也就越浪费
* 多线程 随着同步竞争（如锁、竞争资源冲突等）
2. 多进程、多线程的壁垒
* 进程占用内存 虚拟内存4GB(32bit OS),线程占用内存 4MB
* 高CPU调度消耗

### 携程
1. N:1 无法利用多个CPU,出现阻塞的瓶颈
2. 1:1 跟多线程、多进程模型无异 ；切换携程成本代价昂贵
3. M:N 能够利用多核，过于依赖协程调度器的优化和算法  


### golang 调度器的优化
* 占用空间小，4kb,可大量开辟
* 灵活调度 切换成本底

## GMP模型设计思想
![img.png](go硬核干货/img_8.png)
### GMP模型简介
#### GMP含义
* G 携程
* P 处理器 通过GOMAXPROCS 设置
> 为什么p的个数要和cpu个数一致，因为并行执行的最大数量为cpu核数
* M 内核线程
#### 全局队列
存放等待运行的G   
包含全局队列锁
#### P的本地队列 
* 存放等待运行的G
* 数量限制，不超过256G
* 优先将新创建的G放在P的本地队列中，如果满了会放在全局队列中
#### P列表 
* 程序启动时候创建
* 最多有GOMAXPROCS个

#### M列表
当前操作系统分配到当前Go程序的内核线程数

#### P和M的数量
P的数量问题   
1. 环境变量$GOMAXPROCS  
2. 在程序中使用runtime.GOMAXPROCS()方法来设置

M的数量问题
1. GO语言本身限定的M最大量是10000 
2. runtime/debug 包中的SetMaxThreads函数来设置
3. 如果有一个M阻塞，会创建新的M,如果M空闲，那么会回收或者随眠，M的数量是一个动态的值


### 调度器的设计策略
#### 复用线程
避免频繁的创建、销毁线程、而是对线程的复用  
* work stealing机制
> 当本线程无可运行的G时，尝试从其它线程绑定的P偷取G,而不是销毁线程 
* handle off 机制  
> 当本线程因为G进行系统调用阻塞时，线程释放绑定的P,把P转移给其它空闲的线程执行
#### 利用并行
GOMAXPROCS 设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行  

#### 抢占
在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在GO中，一个goroutine最多占用CPU 10 ms,防止其他goroutine被饿死
![img.png](go硬核干货/img_9.png)


#### 全局G队列
当M执行work stealing从其它P偷不到G时，它可以从全局队列获取G

### go fun() 经历了什么过程
### 调度器的生命周期
### 可视化的GMP编程











