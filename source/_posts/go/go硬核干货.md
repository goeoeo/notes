---
categories:

- go

---

# 字符串

字符串结构: 指向数据地址的指针(8字节)+字符串长度变量(8字节)

1.string 不可修改,因为在字符串会被分配到只读内存段。  
2.将字符串转换为slice([]byte) ,是重新分配了内存，不会修改原有字符串。  
3.使用unsafe包 将slice 指向原字符串的内存，也不能修改，强制修改会包 panic

<!--more-->

# slice

slice结构: 指向数据地址的指针(8字节)+len当前slice长度(8字节)+cap 底层数组的长度(8字节)

## slice 扩容规则

step1: 预估扩容后的容量

1. 预估容量*2 < cap ->newCap=cap
2. 如果oldLen < 1024 -> newCap=oldCap*2 ,否则 newCap=oldCap*1.25

> golang1.16.5 后 是oldCap < 1024 -> newCap=oldCap*2 ,否则 newCap=oldCap*1.25 step2: newCap个元素需要多大的内存   
内存= 预估容量* 元素类型大小

step3: 匹配到合适的内存规格

# 内存对齐

## 为什么要内存对齐？

cpu为了快速读取内容，

## 什么是内存对齐 ？

为保证程序顺利高效的运行，编译器会把各种类型的数据安排到合适的地址，并占用合适的长度，这就是内存对齐 。 每种类型的对齐值，就是他的对齐边界

内存对齐要求数据存储地址，以及占用的字节数都要是他对齐边界的倍数

## 平台对应的最大对齐边界

寄存器宽度、机器字长  
数据类型的对齐边界为与平台最大对齐边界取较小的那个。

## 结构体占用字节数?

结构体字节数需要是对齐边界的倍数，因为要考虑数组。只有每个结构体的大小是对齐值的整数倍，才能保证数组里面每个类型都是内存对齐的。

# Map

键值对的存储一般都会使用hash表   
哈希表通常会有一堆桶（buckets）来存储键值对，通过哈希函数将键值对的键处理成键hash值，利用hash值来选择桶

## 选桶算法(m为桶的数量)：

1. 取模法 hash%m
2. 与运算 hash&(m-1)

> golang 使用的与运算法。

## hash冲突

两个key通过hash函数算出的hash值相同  
解决hash冲突的办法

1. 开放地址法，将冲突的hash放到下一个的桶中寻找，当桶找不到则到下一个桶中寻找，直到遇到空桶
2. 拉链法，编号为2的桶被占用了，在2后面链一个新桶，当前桶找不到，去链接的桶里面寻找。  
   hash的发送会影响哈希表的读写效率，选择散列均匀的hash函数可以减少hash冲突的发生，适时的对哈希表进行扩容也是保证读写效率的有效手段

## hash扩容

通常会吧存储键值对的数据与桶数目的比值作为是否需要扩容的判断依据，这个比值叫**负载因子(LoadFactor)**  
数据迁移，把旧桶里存储的键值对都迁移到新桶里。如果哈希表存储的键值对较多，一次性迁移所有桶花费的时间比较显著，所以通常会在哈希表扩容时，先分配足够多的新桶 然后用一个字段记录旧桶的位置，再增加一个字段记录旧桶迁移的进度(
如记录下一个需要迁移的旧桶编号)，如果hash表每次在进行读写操作时，如果检测到当前处于扩容阶段
就完成一部分键值对迁移任务，直到所有的旧桶迁移完成，旧桶不在使用，才算真正完成一次哈希表的扩容，像这样把键值对迁移的时间分摊到多次哈希表操作的方式，叫做渐进式扩容。  
渐进式扩容，可以避免一次性扩容的瞬时抖动。

## go语言中Map类型的底层实现就是哈希表

Map 类型的变量本质上是一个指针, 指向hmap  
一个桶里可以放8个键值对，但是为了让内存更加紧凑，8个key放一起，8个value放一起，在8个key前面是8个tophash  
每个tophash都是对应hash值的高8位 ,overflow 存的是溢出桶   
实际上如果哈希表要分配桶的数据大于2^4次方，就会认为使用溢出桶的几率比较大，就会预分配2^(B-4)个溢出桶备用
![](go硬核干货/bmap.png)

```go
package Map

import "unsafe"

//Map 底层结构体
type hmap struct {
	count      int //键值对数目
	flags      uint8
	B          uint8  //B 记录桶的数目的幂，桶数=2^B，因为选择桶用的是与运算的方法
	noverflow  uint16 //使用溢出桶的数量
	hash0      uint32
	buckets    unsafe.Pointer //当前桶
	oldbuckets unsafe.Pointer //旧桶
	nevacuate  uintptr        //渐进式扩容阶段，即将迁移的旧桶编号
	extra      *mapextra
}

//记录溢出桶的相关信息
type mapextra struct {
	overflow     unsafe.Pointer //已经使用的溢出桶
	oldoverflow  unsafe.Pointer //用于在扩容阶段存储旧通用到的那些溢出桶的地址
	nextoverflow unsafe.Pointer //下一个空闲溢出桶
}

//桶
type bmap struct {
}

```

## go Map的扩容规则

* count/(2^5) > 6.5 => 翻倍扩容
* LoadFactor没有超标并且noverflow 较多 => 等量扩容

> noverflow较多的情况:  
> 1.B<=15,noverflow>2^B  
> 2.B>15,noverflow>2^15

### 等量扩容

创建与原来相同数量的桶  
为什么要进行等量扩容？  
在溢出桶使用较多，负载因子较低的时候，说明删除了大量的键。通过等量扩容，减少溢出桶的使用。

# 函数调用栈

我们按照编程语言的语法定义的函数，会被编译器编译成一堆堆的机器指令，写入可执行文件。  
执行时，可以执行文件被加载到内存中，这些机器指令，对应虚拟地址空间中位于代码段。如果在一个函数中调用另外一个函数，编译器就会生成一条call指令。  
程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条ret指令，负责在函数结束后，调回到调用处，继续执行。  
函数执行时，需要有足够的内存空间，供它存放局部变量、参数等数据，这段空间对应到虚拟地址空间的栈，栈只有一个口可以出，先入后出规则  
运行时，栈上面是高地址，向下增长，分配给函数的栈空间称为函数栈帧（stack frame），函数栈帧由栈底（bp 栈基）到栈顶（sp 栈指针）

**go 语言中函数栈帧布局**   
调用者栈基地址  
局部变量  
调用函数的返回值  
参数

call 指令 只做两件事，第一将下一条指令的地址入栈，这就是返回地址，被调用函数执行结束后会跳回到这里，继续执行。第二跳转到被调用函数的入口
处执行，所有的函数栈帧布局都遵循统一的约定，所以被调用者是通过栈指针加上偏移来定位到每一个参数好返回值的  
程序执行时cpu 用特定的寄存器，来存储运行时 栈基和栈指针，用指令指针寄存器用于存储下一条要执行的指令地址  
go语言中函数栈帧不是逐步扩张的，而是在分配栈帧时，直接将栈指针移动到所需最大栈空间的位置，然后通过栈指针加偏移值，这种相对寻址方式使用函数 栈帧。之所以一次行分配，主要是为了避免发送栈访问越界。

ret 指令 1.弹出返回地址，2.跳转到返回地址。  
每个函数开始时会分配栈帧，结束前又会释放自己的栈帧

## go语言中返回值赋值早于defer函数

```go
package main

import "fmt"

func incr(a int) int {
   var b int
   defer func() {
      a++
      b++
   }()
   a++
   b = a
   return a
}

func main() {
   var a, b int
   b = incr(a)
   fmt.Println(a,b)//0,1
}
```
```go
package main

import "fmt"

func incr(a int) (b int) {
   defer func() {
      a++
      b++
   }()
   a++
   return a
}

func main() {
   var a, b int
   b = incr(a)
   fmt.Println(a,b)//0,2
}
```

## 一个函数中调用了多个函数，且参数和返回值各不相同  
如果一个函数A调用了两个函数B、C ,但是这两个函数的参数和返回值占用的空间并不相同，go语言的函数栈帧是一次性分配的，要
以最大的参数加返回值空间为标准来分配，才能满足所有被调用函数的需求。被调用者通过栈指针相对寻址来定位自己的参数和返回值

# 闭包
go 语言中函数是头等对象，可以作为参数传递，可以作为函数返回值，也可以绑定到变量，Go语言称这样的参数、返回值、或变量为function value，
函数指令在编译起见生成，而function value 本质上是一个指针，但是并不直接指向函数指令入口，而是指向一个runtime.funcval的结构体,这个结
构体里只有一个地址fn，这个地址就是函数指令的入口地址。
```go
package runtime
type funcval struct {
	fn uintptr
}
```
## 为什么需要通过funcval结构体来包装执行函数的地址,然后使用一个二级指针来调用呢？
这里主要是为了处理闭包的情况。  
> 闭包：要包括自由变量（在函数外部定义但在函数内部引用）；脱离了形成闭包的上下文，闭包也能正常使用这些自由变量

![](go硬核干货/img.png)  
函数create 的返回值是一个函数，但这个函数内部使用了外部定义的变量c，即使create执行结束，通过f1，f2也能正常执行这个闭包函数，并使用定义
在create函数内部的局部变量c，所以这里符合闭包的定义，通常称这个变量c为捕获变量。  
闭包函数的指令自然也在编译阶段生成，但因为每个闭包对象都要保存自己的捕获变量，所以要到执行阶段才创建对应的闭包对象。  
到执行阶段，main函数栈帧有两个局部变量，然后是返回值空间，到create函数栈帧这里，有一个局部变量c等于2，create函数会在堆上分配一个fucval
结构体，fn指向闭包函数入口，除此之外还有一个捕获列表，这里只捕获了一个变量c，然后这个结构体的起始地址就作为返回值，写入返回值空间。  
通过f1、f2，对应的闭包函数就会找到各自对应的funcval结构体，拿到同一个函数入口，但是会使用不同的捕获列表，这就是称闭包为有状态函数的原因

## 闭包函数是如何找到对应的捕获列表呢？
go语言中通过一个funcval 调用函数时，会把对应的funcval结构体地址存入特定寄存器，例如amd64平台使用的是dx寄存器，这样在闭包函数中就可以通
过寄存器取出funcval结构体的地址，然后加上响应的偏移来找到每一个被捕获的变量。  
所以go语言中，闭包就是有捕获列表的funcval，而没有捕获列表的funcval，直接忽略这个寄存器的值就好了。  

## 捕获列表
捕获列表 不单单只是拷贝变量值。需要分情况。被闭包捕获的变量，在外层函数与闭包函数中表现一致，好像他们在使用同一个变量，为此go语言的编译器
针对不同情况做了不同的处理

### 情况1 
被捕获的变量除了初始化复制外，在其它任何地方都没有修改过  
直接拷贝值到捕获列表中

### 情况2
局部变量除了初始化赋值外还被修改过。
变量会改为堆分配，捕获列表中存的是变量的地址
> 局部变量堆分配，是变量逃逸的一种场景。

### 情况3
如果修改并被捕获的是参数，涉及到函数原型，就不能像局部变量那样处理了  
参数依然通过调用者栈帧传入，但是编译器会把栈上这个参数拷贝到堆上一份，然后外层函数和闭包函数都使用堆上分配的这一个，

### 情况4
如果被捕获的是返回值  
调用者栈帧上依然会分配返回值空间，不过闭包的外层函数会在堆上也分配一个，外层函数和闭包函数都使用堆上分配的这一个，在外层函数返回前，需要
把堆上的返回值拷贝到栈上的返回值空间

处理方式虽然多样，但目的只有一个，就是保持捕获变量在外层函数与闭包函数的一致性。  

# 方法
如果我们定义一个类型A,并给它定义一个方法Name,然后就可以使用 a.Name 或者 A.Name(a) 来调用Name方法，实际上a.Name是调用语法糖  
![](go硬核干货/img_1.png)  
go语言中 函数只和参数类型与返回值相关，方法就是普通的函数，方法的接受者是隐含的第一个参数

## 方法表达式与方法变量
![](go硬核干货/img_2.png)
方法表达和方法变量 本质上都是一个funcval，方法变量会捕获方法接受者a形成闭包,但这里的f2仅作为局部变量，它与a的生命周期是一致的，所以编译器
会做出优化，把它转换为类型A的方法调用并传入a作为参数 A.Name(a),

# defer
关于defer 我们知道它会在函数返回之前倒叙执行。  
先通过deferproc函数注册defer函数，然后在return之前调用。  
defer信息会注册到一个链表，而当前执行的goroutine持有这个链表的头指针，每个goroutine在执行时都有一个对应的结构体g，其中有一个字段_defer指向
defer链表的头，_defer 链表链起来的是一个一个defer结构体，新注册的defer会添加到链表的头部。执行时也是从头开始，所以defer才会表现为倒叙执行。  

defer 结构体  
![](go硬核干货/img_3.png)

## go1.12defer 的问题
1. _defer在堆上分配 ，即使有预分配的deferpool,也需要去堆上获取与释放，而且参数还要在堆栈间来回拷贝  
2. 使用链表注册defer信息，而链表本身操作比较慢

## go1.13和go1.14对defer的改进











