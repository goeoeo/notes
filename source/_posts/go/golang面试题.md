---
categories: 
- go

tags:
- goland面试题
---

## golang 调度
* CSP(通信顺序进程)
* 顺序一致性模型 
    > 1.Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的;  
    2.不同的Goroutine之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考
<!--more-->
* Goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度 。以下是可能导致调度的点 
    > 1.I/O,select  
    2.channel  
    3.等待锁  
    4.函数调用（有时）  
    5.runtime.Gosched(),由程序主动交出控制权

## go 结构体能不能进行比较
* 如果结构体的所有成员变量都是可以比较的，那么结构体就可以比较
* 结构体之间进行转换需要他们具备完全相同的成员（字段名，字段类型，字段个数）
* 切片，map不能进行比较

## 结构体可以作为map的key吗
* 结构体必须是可以比较的，才能作为key，否则编译报错
 
## go defer 先进后出，栈结构
 
## select作用
* 用于监听和channel有关的IO操作，当IO操作触发时，触发相应的动作
* 所有的channel表达式都会被求值，所有被发送的表达式都会被求值，求值顺序：自上而下，从左到右
* select常用于协程的安全退出
 
## context包
* context 一般理解为程序单元（goroutine）的一个运行状态，现场，快照,通过context将当前程序的状态传递给下（goroutine）
* context 常用于将过期或者撤销的信号传递给被调用的程序单元

## 主协成如何等待其余协程完成
* 使用channel进行通信
* 使用sync.WaitGroup包
 
## slice,len,cap,共享,扩容
* slice底层数据结构由，数组，len,cap 组成，append扩容时是以当前容量的2倍进行扩容
* slice 加锁可以实现消息队列

## map
* map 是非线程安全的，多个协程同时操作一个map，会导致程序崩溃
* map 是无序的，想要顺序读取，可将map的key放入切片后排序后进行map读取
* map key是唯一的，可用于实现set集合
* map 可实现发布订阅

## 大文件排序
* 归并算法
* 利用goroutine 并发排序缩短时间

## 标准Http协议6种请求方法
* GET
* POST
* PUT
* DELETE
* HEAD
    > HEAD 常用于判定某个资源是否存在 
* Options
    > 用于检查资源地址是否有效

    
## 分布式事务
* 2PC
* TCC
* 本地消息表
* MQ事务（RocketMQ）

## golang中值类型和引用类型
* 值类型分别有：int系列、float系列、bool、string、数组和结构体
* 引用类型有：指针、slice切片、管道channel、接口interface、map、函数等
* 值类型的特点是：变量直接存储值，内存通常在栈中分配
* 引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配,编译器会隐式地为我们解引用，取到指针指向的实际变量


## Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？
Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。

## 无缓冲 Chan 的发送和接收是否同步?
无缓冲的channel由于没有缓冲发送和接收需要同步.  
有缓冲channel不要求发送和接收操作同步.   
channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。  
channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。  

## go语言的并发机制以及它所使用的CSP并发模型 GMP
CSP模型是上个世纪七十年代提出的,不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。  
Golang中channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实类似一个阻塞的消息队列。  
Goroutine 是Golang实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：  
* 用户空间 避免了内核态和用户态的切换导致的成本。
* 可以由语言和框架层进行调度。
* 更小的栈空间允许创建大量的实例。

Golang中的Goroutine的特性:  
Golang内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）.  
* G（Goroutine）我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息.
* M（Machine） 对内核级线程的封装，数量最大值为1000
* P（Processor） 即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数.

GMP调度原理:  
Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。  
M想要执行G,必须先获得P,在go中有,两个队列,一个全局的G队列和P本地队列,M从P本地队列中获取G,如果P本地队列为空,则从全局队列中拉取一些G放到本地队列,如果全局队列为空则从其他P本地队列偷取G来,放到自己的本地队列中.如果偷取失败,则当前M进入自旋状态,等待可执行的G,  
而其他未获得P的会进入休眠状态,一定时间过后会被操作系统回收.
如果当前M执行G的过程中G发生阻塞,则P会立即分离出来,寻找空闲M进行绑定

Golang的CSP并发模型，是通过Goroutine和Channel来实现的。  
Goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。 Channel是Go语言中各个并发结构体(Goroutine)之前的通信机制。通常Channel，是各个Goroutine之间通信的”管道“，有点类似于Linux中的管道。  
在通信过程中，传数据channel <- data和取数据<-channel必然会成对出现，因为这边传，那边取，两个goroutine之间才会实现通信。  


## Golang 中常用的并发模式？
### 生产者消费者模型
并发编程中最常见的例子就是生产者消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致CPU被剥夺的下岗问题。
### 发布订阅模型
发布订阅（publish-and-subscribe）模型通常被简写为pub/sub模型。在这个模型中，消息生产者成为发布者（publisher），而消息消费者则成为订阅者（subscriber），生产者和消费者是M:N的关系。在传统生产者和消费者模型中，是将消息发送到一个队列中，而发布订阅模型则是将消息发布给一个主题。
### 控制并发数
利用带缓存的channel实现
### 赢者为王
开启多个Goroutine 执行相同的任务,谁先返回,取谁的结果
### 并发的安全退出
通过select和channel 实现
### context包
在Go1.7发布时，标准库增加了一个context包，用来简化对于处理单个请求的多个Goroutine之间与请求域的数据、超时和退出等操作  

### 通过sync.WaitGroup实现并发控制


## JSON标准库对nil slice和空slice的处理是一致的吗？　
不一直,nil slice会序列化成null ,空slice会序列化成空数组[]

##  协程，线程，进程的区别。

### 进程
程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
### 线程
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
### 协程
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。


## 互斥锁，读写锁，死锁问题是怎么解决
### 互斥锁
互斥锁就是互斥变量mutex，用来锁住临界区的.  
条件锁就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行；读写锁，也类似，用于缓冲区等临界资源能互斥访问的。  
### 读写锁
通常有些公共数据修改的机会很少，但其读的机会很多。并且在读的过程中会伴随着查找，给这种代码加锁会降低我们的程序效率。读写锁可以解决这个问题。  
> 注意：写独占，读共享，写锁优先级高

### 死锁
一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。 另外一种情况是：若线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。
#### 死锁产生的四个必要条件
1.互斥条件：一个资源每次只能被一个进程使用  
2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  
3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。  
 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。  
### 怎么解决死锁问题
#### 预防死锁
可以把资源一次性分配：（破坏请求和保持条件）  
然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）  
资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

#### 避免死锁
预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。
#### 检测死锁
首先为每个进程和每个资源指定一个唯一的号码,然后建立资源分配表和进程等待表.
#### 解除死锁
当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有:  
1. 剥夺资源 从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态.
2. 撤消进程 可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止.所谓代价是指优先级、运行代价、进程的重要性和价值等。

##  Golang的内存模型，为什么小对象多了会造成gc压力
### 面向并发的内存模型
常见的并行编程有多种模型，主要有多线程、消息传递等。Go语言是基于消息并发模型的集大成者，它将基于CSP模型的并发编程内置到了语言中,并且go语言是共享内存的  

### Goroutine和系统线程
Goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度；同时发生在用户态，调度器会根据具体函数只保存必要的寄存器，切换的代价要比系统线程低得多。运行时有一个runtime.GOMAXPROCS变量，用于控制当前运行正常非阻塞Goroutine的系统线程数目。  
### 原子操作
所谓的原子操作就是并发编程中“最小的且不可并行化”的操作。

### 顺序一致性内存模型
在Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的。但是不同的Goroutine之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考。

通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配.