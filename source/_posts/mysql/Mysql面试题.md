## 问题
### 主键超键候选键外键
* 超键（super key）:在关系中能唯一标识元组的属性集称为关系模式的超键
* 候选键（candidate key）:不含有多余属性的超键称为候选键
* 主键（primary key）:用户选作元组标识的一个候选键称为主键
* 外键（foreign key）:在一个表中存在另一个表的主键，称此键为此表的外键

### 数据库事务的四个特性及含义(ACID)
* 原子性（Atomicity）:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在某个环节。事务在执行过程中发生错误，会被回滚到事务
开始前的状态
* 一致性（Correspondence）:在事务开始之前和事务结束之后，数据的完整性约束没有被破坏
* 隔离性（Isolation）:并发执行的事务彼此无法看到对方的中间状态
* 持久性(Durability)：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

### 事务的并发问题
* 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
* 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
* 幻读：事务 A 重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务 B 提交的行。

### MySQL事务隔离级别
|事务隔离级别|脏读|不可重复读|幻读|
|:---|:---:|:---:|:---:|
| 读未提交（read-uncommitted）|是|是|是|
| 不可重复读（read-committed）|否|是|是|
| 可重复读（repeatable-read）|否|否|是|
| 串行化（serializable）|否|否|否|


### 视图的作用，视图可以更改么
视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。  

使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。  
视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。

创建视图：create view XXX as XXXXXXXXXXXXXX;  
对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；

但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。

### drop,delete与truncate的区别
* drop 是删除整张表（结构和数据）
* delete 是删除数据
* truncate 清空表，使得表恢复到初始状态
> 执行速度： drop>truncate>delete


### 索引的工作原理及其种类
#### 什么是索引
在关系数据库中，索引是一种单独的、物理的数对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。  

#### 工作原理
索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。

#### 为什么需要建立索引
当数据保存在磁盘类存储介质上时，它是作为数据块存放。这些数据块是被当做一个整体来访问的，这样是为了保证操作的原子性。磁盘数据块存储结构类似于链表存储结构，每个数据块包含数据部分，以及指向下一个数据块(节点)的指针，不要连续的数据块进行存储。

记录集只能在某一个关键字段上排序，因此如果想要在一个无序字段上搜索数据，就要执行一个线性搜索的过程，平均需要访问N/2个数据块，N表示数据占用的数据块数目。

如果这个字段是一个非主键字段(也就是说，不包含唯一访问入口)，那么需要访问整个数据存储的数据块。  
而如果数据是有序的，则可以使用二分法查找，这样只需要访问log2(N)的数据块，这也就是我们为什么有序的字段查询速度更快的原因。

#### 索引类型
Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。

* FULLTEXT 即为全文索引，目前只有MyISAM引擎支持。使用场景少，可使用其他方案代替
* HASH 因为hash表在处理较小数据量时具有无可比拟的素的优势，所以hash索引很适合做缓存（内存数据库）  
如mysql数据库的内存版本Memsql，使用量很广泛的缓存工具Mencached，NoSql数据库redis等，都使用了hash索引这种形式。
* BTREE Mysql默认的索引类型，具有普遍的适用性
* RTREE 相对于BTREE，RTREE的优势在于范围查找.很少使用

#### mysql中sql语句与索引相关的地方
* myisam里所有键（索引）的长度仅支持1000字节，innodb是767.
>767字节是MySQLVersion 5.6和InnoDB表(和以前的版本)的限制长度。MyISAM表的长度为1000字节。在MySQLVersion 5.7及以上版本中，这个限制已经增加到3072字节。  
>如果你在一个大char或varchar字段上设置了一个索引，该字段是utf8mb4编码的，则必须将最大索引前缀长度767字节(或3072字节)除以4，结果为191字节。这是因为utf8mb4字符的最大长度是4个字节。对于UTF 8字符，它将是三个字节，导致最大索引前缀长度为254。

* blob和text字段仅支持前缀索引.
* 使用!=以及<>不等于的时候，mysql不使用索引.
* 当在字段使用函数的时候，mysql无法使用索引；在join时条件字段类型不一致的时候，mysql无法使用索引；在组合索引里使用非第一个索引时也不使用索引.
* 在使用like的时候，以%开头，即"%***"的时候无法使用索引；在使用or的时候，要求or前后字段都有索引.
           

### 连接的种类
* 笛卡尔积 （join）
* 左连接（left join）
* 右连接（right join） 
* 内连接 （inner join）


### 数据库范式
#### 范式的简介
范式的英文名称是Normal Form，它是英国人E.F.Codd（关系数据库的老祖宗）在上个世纪70年代提出关系数据库模型后总结出来的。范式是关系数据库
理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。目前有迹可寻的共有8种范式，依次是：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。
通常所用到的只是前三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。

数据往往种类繁多，而且每种数据之间又互相关联，因此，在设计数据库时，所需要满足的范式越多，那表的层次及结构也就越复杂，最终造成数据的处理困难。
这样，还不如不满足这些范式呢。所以在使用范式的时候也要细细斟酌，是否一定要使用该范式，必须根据实际情况做出选择。一般情况下，我们使用前三个范式已经够用了，
不再使用更多范式，就能完成对数据的优化，达到最优效果。

#### 通俗的理解
* 第一范式   
属性不可分割，每个字段都应该是不可再拆分的。  
比如一个字段是姓名（NAME），在国内的话通常理解都是姓名是一个不可再拆分的单位，这时候就符合第一范式；但是在国外的话还要分为FIRST NAME和LAST NAME，
这时候姓名这个字段就是还可以拆分为更小的单位的字段，就不符合第一范式了。

* 第二范式   
要求表中要有主键，表中其他其他字段都依赖于主键。  
因此第二范式只要记住主键约束就好了。比如说有一个表是学生表，学生表中有一个值唯一的字段学号，那么学生表中的其他所有字段都可以根据这个学号字段去获取，
依赖主键的意思也就是相关的意思，因为学号的值是唯一的，因此就不会造成存储的信息对不上的问题，即学生001的姓名不会存到学生002那里去。

* 第三范式  
要求表中不能有其他表中存在的、存储相同信息的字段，通常实现是在通过外键去建立关联，因此第三范式只要记住外键约束就好了。  
比如说有一个表是学生表，学生表中有学号，姓名等字段，那如果要把他的系编号，系主任，系主任也存到这个学生表中，那就会造成数据大量的冗余，
一是这些信息在系信息表中已存在，二是系中有1000个学生的话这些信息就要存1000遍。因此第三范式的做法是在学生表中增加一个系编号的字段（外键），
与系信息表做关联。

### 数据库优化的思路
#### 数据库方面
* 建立索引
* 分库、分表、分区
* 数据库引擎（无理由使用Innodb）  
mysql比较常用的数据库引擎是：innodb 、myisam;  
myisam是表级锁，适用于一次插入多次查询的表，或者是读写分离中读库中的表  
innodb是行级锁，适用于频繁更新，插入，读写分离写库中的表
* 预处理  
实时数据放入缓存中  
历史数据，将复杂sql语句执行出来的结果生成视图，查询的时候直接查询视图，速率显著提高。  
* 读写分离
* 增加服务器内存、CPU及网络带宽

#### Sql优化
* 对查询进行优化，尽量避免全表扫描，首先考虑在where及order by涉及的列上加索引
* 避免在where子句中对字段进行null值判断，比如select id from where num is null 将会放弃索引进行全表扫描。 解决办法是设置为默认值，比如0。
* 避免在where子句中使用!= 或者<>,否则会放弃索引进行全表扫描
* 避免在where子句中使用or来连接条件，否则会放弃索引进行全表扫描 解决办法使用union all
* 避免全模糊查询，比如select id from a where name like '%abc%'，将放弃索引进行全表扫描;解决办法使用右模糊查询，
* 避免隐式转换，比如varchar类型的字段a = 1 ，如此会放弃索引进行全表扫描
* 避免在where子句=的左边进行函数、算数运算或则其他表达式运算，否则将放弃索引进行全表扫描
* 尽量使用数字型字段，若只包含数字信息的字段尽量不要设计成字符串类型

参考文章：[MySQL数据库优化两三事](https://sq.163yun.com/blog/article/183654375478206464)



 
### 存储过程与触发器的区别

#### 存储过程
是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。

#### 触发器
触发器是一种特殊类型的存储过程，它又不同于存储过程，触发器主要是通过事件进行触发而被执行的，而存储过程可以通过存储过程名字而被直接调用