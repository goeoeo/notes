---
categories: 
- docker
tags:
- docker面试题
---


## 什么是虚拟化？
虚拟化允许在同一硬件上运行两个完全不同的操作系统，每个客户操作系统都经历了引导，加载内核等所有过程。可以拥有非常严格的安全性！  

可以基于虚拟化方法如何模仿客户操作系统的硬件并模拟客户操作环境来对虚拟化方法进行分类。  

主要有三种类型的虚拟化：  
* 仿真
* 半虚拟化
* 基于容器的虚拟化
<!--more-->


## docker与虚拟机有何不同？
docker不是虚拟化方法，它依赖与实际实现基于容器的虚拟化或操作系统及虚拟化的其他工具。为此，docker最初使用LXC驱动程序，然后移动到libcontainer现在重命名为runc。Docker主要专注于在应用程序容器内自动部署应用程序。应用程序容器旨在打包和运行单个服务，而系统容器则设计为运行多个进程，如虚拟机。因此，Docker被视为容器化系统上的容器管理或应用程序部署工具。  
主要表现在以下几个方面：  
* 与虚拟机不同，容器不需要引导操作系统内核，因此可以在不到一秒的时间内创建容器。此功能使基于容器的虚拟化比其他虚拟化方法更加独特和可取；
* 由于基于容器的虚拟化为主机增加了很少或没有开销，因此基于容器的虚拟化具有接近本机的性能；
* 对于基于容器的虚拟化，与其他虚拟化不同，不需要其他软件；
* 主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求；
* 与虚拟机映像相比，容器状态（Docker或LXC映像）的大小很小，因此容器映像很容易分发；
* 容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。虽然主机的所有资源都在虚拟机中可见，但无法使用。这可以通过在容器和主机上同时运行top或htop来实现。所有环境的输出看起来都很相似；

## CI（持续集成）服务器的功能是什么？
CI功能就是在每次提交之后不断地集成所有提交到存储库的代码，并编译检查错误。  

## 容器内部机制？
每个容器都是在自己的名命空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。  

## 什么是docker？
docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保应用程序在任何环境中无缝运行；  
docker容器，将一个软件包装在一个完整的文件系统中，该文件系统包含运行所需的一切：代码、系统工具、系统库等可以安装在服务器上的任何东西；  

## 什么是docker镜像？
docker镜像是docker容器的源代码，Docker镜像用于创建容器。

## 什么是docker容器？
Docker容器包括应用程序及其所有依赖项，但与其他容器共享内核，作为主机操作系统上用户空间中的独立进程运行。Docker容器不依赖于任何特定的基础架构：它们可以在任何计算机，任何基础架构和任何云中运行。

## docker容器常见的几种状态？
* 运行；
* 已暂停；
* 重新启动；
* 已退出；

可以通过运行“docker ps –a”命令来识别Docker容器的状态，这将依次列出所有可用的docker容器及其在主机上的相应状态。

## docker的基本使用流程？
1. 一切都从Dockerfile开始，Dockerfile是镜像的源代码；
2. 创建Dockerfile后，可以构建它以创建容器的镜像，镜像只是“源代码”的“编译版本”，即Dockerfile；  
3. 获得容器的镜像后，应使用注册表重新分发容器。注册表就像一个git存储库——可以推送和拉取镜像；  
4. 接下来，就可以使用该镜像来运行容器，在许多方面，正在运行的容器与虚拟机非常相似；

## Dockerfile中常见的指令？
* 1）FROM:构建镜像基于哪个镜像；
* 2）MAINTAINER：镜像维护者姓名或邮箱地址；
* 3）RUN：构建镜像时运行的shell指令；
* 4）CMD：运行容器时执行的shell环境；
* 5）EXPOSE：声明容器的服务端口（仅仅是声明）；
* 6）ENV：设置容器环境变量；
* 7）ADD：拷贝文件或目录到容器中，如果是URL或压缩包便会自动下载或自动解压；
* 8）COPY：拷贝文件或目录到容器中，跟ADD类似，但不具备自动下载或解压的功能；
* 9）ENTRYPOINT：运行容器时执行的shell命令；
* 10）VOLUME：指定容器挂载点到宿主机自动生成的目录或其他容器；
* 11）USER：为RUN、CMD、和ENTRYPOINT执行命令指定运行用户；
* 12）WORKDIR：为RUN、CMD、ENTRYPOINT、COPY和ADD设置工作目录，意思为切换目录；
* 13）HEALTHCHECH：健康检查；
* 14）ARG：构建时指定的一些参数；
* 15）LABEL：我们使用LABEL按照项目，模块，许可等组织我们的镜像。我们也可以使用LABEL来帮助实现自动化。在LABEL中，我们指定一个键值对，以后可用于以编程方式处理Dockerfile；

注意：  
（1）RUN在building时运行，可以写多条；  
（2）CMD和ENTRYPOINT在运行container时，只能写一条，如果写多条，最后一条生效；  
（3）CMD在构建容器时可以被COMMAND覆盖，ENTRYPOINT不会被COMMAND覆盖，但可以指定——entrypoint覆盖；  
（4）如果在Dockerfile文件中需要往镜像中导入文件，则该文件必须在Dockerfile所在目录或子目录中；  
（5）每个目录下最好就只有一个Dockerfile，如果有多个Dockerfile文件时，使用Dockerfile生成镜像时便需要使用“-f”来指定具体的Dockerfile文件；  
（6）指令必须全部为大写；  
（7）使用Dockerfile生成镜像时，保证Dockerfile中所需的软件、文件与Dockerfile在同一个目录下；  

## dockerfile的ONBUILD指令？
当镜像用作另一个镜像构建的基础是，ONBUILD指令向镜像添加将在稍后执行的触发指令。如果要构建其他镜像的基础的镜像（例如，可以使用特定于用户的配置自定义的应用程序构建环境或守护程序），这将非常有用。

##　docker镜像和层有什么区别？
镜像：Docker镜像是由一些列只读层构建的；　　
层：每个层代表镜像Dockerfile中的一条指令；　　
重要的是，每个层只是与之前一层的一组差异层（相同的就不再放到锌层中）；　　

## 什么是docker swarm？
docker swarm是Docker的本机群集，它将Docker主机池转变为单个虚拟Docker主机。Docker swarm提供标准的Docker API，任何已经与Docker守护进程通信的工具都可以使用Swarm透明地扩展到多个主机。

## 如何在多个环境中使用Docker？
可以进行以下更改：  
* 删除应用程序代码的任何卷绑定，以便代码保留在容器内，不能从外部更改；
* 绑定到主机上的不同端口;
* 以不同方式设置环境变量（例如，减少日志记录的详细程度，或启用电子邮件发送）；
* 指定重启策略（例如，重启：始终）以避免停机；
* 添加额外服务（例如，日志聚合器）；
因此，希望定义一个额外的Compose文件，它指定适合生产的配置。此配置文件只需要包含您要从原始Compose文件中进行的更改。

## docker默认的网络类型？
docker默认情况下，有五种网络模式：  
* host模式：直接使用docker宿主机的I网络。如IP地址、网卡类型等；
* none模式：不会给容器进行任何网络配置。也就是说，使用这种模式的容器没有IP地址（只有一个回环地址）；
* bridge模式：docker默认的网络配置，此模式会为每一个容器分配名称空间，可以设置IP，但是要与docker host主机的虚拟网络在同一网段；通过虚拟网卡与外界通信；
* container模式：这种模式与已经存在的容器共有同一个IP地址；
* Network：自定义网络。可以自行创建并且可以注定多种网络驱动，如bridge、overlay等；

## docker容器的跨主机网络通信？
跨主机通信的两种解决方案：  
* overlay网络：使用这种方法，需要事先创建一个consul服务，将需要跨主机通信的docker host加入到同一个consul集群中，然后再创建一个overlay类型的自定义网络。由于其网卡作用于是全局的，所以基于此网卡类型创建的容器就可以正常通信；  
* macvlan网络：使用这种方法，首先开启网卡的混杂模式，然后配置虚拟网卡，这些虚拟网卡拥有独立的mac地址，可以配置IP地址进行通信。与overlay不同的是，macvlan的作用范围是本地有效。

> 如果使用macvlan网络的方式，需要以下步骤：  
> * 首先要保证需要跨主机通信的docker hos是可以正常通信的；
> * 两台docker host创建的虚拟网卡是在同一网段；
> * 然后两台docker host基于虚拟网卡创建macvlan类型的网卡；
> * 通过macvlan网络类型创建的容器即可通信；

## docker数据持久化
docker实现数据持久化的方式：  
### Bind mount（绑定挂载）：
创建容器时，使用“-v”选项，将本地的目录挂载到容器中。采用这种方式容器的挂载类型为bind！  
#### 特点：
* Data Volume是目录或文件，不能是没有格式化的磁盘（块设备）；
* 容器可以读写volume中的数据；
* 随源文件变化而变化；
* volume数据可以永久保存，即使使用它的容器已经被销毁；

#### 注意：
* DockerHost上需要被挂着的源文件或目录，必须是已经存在，否则，当做的一个目录挂着到容器中；
* 默认挂载到容器内的文件，容器是有读写权限。可以在运行容器是-v后边加“：ro” 限制容器的写入权限；
* 可以挂载单独的文件到容器内部，使用场景：如果不想对整个目录进行覆盖，而只希望添加某个文件，就可以使用挂载单个文件；

### Manager Volume（数据卷管理员）
创建容器时，使用“-v“选项，只指定容器中的目录即可！采用这种方式容器的挂载类型为volume；  

#### 特点：
* 随着源文件的变化而变化，跟Bind mount效果是一样；
* 删除容器的操作，默认不会对dockerhost主机上的原文件进行删除，如果想要在删除容器是将原文件删除，可以在删除容器时添加“-v”选项，（一般情况下不建议使用，因为文件有可能被其他容器就使用）；

### Volume containe（容器与容器的数据共享）
采用这种方式，即事先创建一个容器，专用于挂载本地的目录，然后创建容器时，使用“--volumes-from”指定挂载本地目录的容器即可（这种模式是将原本容器中挂载的所有目录都挂载到新创建的容器中）！

这种方式也是提供bind mount模式和manager volume模式！