---
title: golang面试题
categories: 
- interview
tags:
- golang
---

# rpc微服务框架
## 微服务之间如何进行通信？
* 单体项目时：一次服务调用发生在同一台机器上的同一个进程内部，也就是说调用发生在本机内部，因此也被叫作本地方法调用。
* 微服务项目时：服务提供者和服务消费者运行在两台不同物理机上的不同进程内，它们之间的调用相比于本地方法调用，可称之为远程方法调用，简称 RPC

## RPC了解多少？都有哪些？
受限语言的开源 RPC 框架   
* Dubbo (java)
* Motan (java)
* Tars (c++)
* Spring Cloud Feigh (java)

跨语言平台的开源 RPC 框架  
* GRPC：Google 2015 年开源，支持多种语言
* Thrift：最初Facebook 开发的内部框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。

## RPC包含哪些部分？
* 客户端和服务端建立网络连接模块( server模块、client模块 )
* 服务端处理请求模块
* 协议模块
* 序列化和反序列模块

## 设计一个RPC会考虑哪些问题?
* 客户端和服务端如何建立网络连接？
* 服务端如何处理请求？
* 数据传输采用什么协议？
* 数据该如何序列化和反序列化？

## 服务端如何处理请求？有哪些方式？
服务端接收到客户端的请求后，常见的处理方式有三种，分别是BIO、NIO和AIO。  
* **同步阻塞方式（BIO）** 客户端发一次请求，服务端生成一个对应线程去处理。当客户端同时发起的请求很多时，服务端需要创建多个线程去处理每一个请求，当达到了系统最大的线程数时，新来的请求就无法处理了。
* **同步非阻塞方式 (NIO)**  客户端发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过 I/O 多路复用技术进行处理。就是把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。这种方式的优势是开销小，不用为每个请求创建一个线程，可以节省系统开销。
* **异步非阻塞方式（AIO）**  客户端发起一个 I/O 操作然后立即返回，等 I/O 操作真正完成以后，客户端会得到 I/O 操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的 I/O 读写操作，因为真正的 I/O 读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，不存在阻塞等待问题。

> BIO 适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。
> NIO 适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比 BIO，相对来说编程比较复杂。
> AIO 适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I/O 操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。 【来自网络】

### IO多路复用
多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；  
如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；  
而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。  
可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。

IO多路复用实现有三种方案：select、poll、epoll   
特点：
* 专一进程解决多个进程IO的阻塞问题，性能好
* 实现、开发应用难度较大；
* 适用高并发服务应用开发：一个进程（线程）响应多个请求；


### select
select 的fd_set通过bitmap 1024位的方式存储fd  
bitmap从用户态拷贝到内核态，由内核态来判断，没有数据变化，select会阻塞，有变化，bitmap的fd会被置位

缺点：
1. 1024的大小限制
2. fdset不可重用
3. rset(bitmap) 用户态到内核态的开销
4. 复杂度为O(n)

### poll
poll将要监听的对象存到数组中，且数组中的元素是结构体
```
struct pollfd
{
    int fd;
    short events;//事件
    short revents;//有变化被置位，什么事件，置为什么事件，最后要将revents重新置为0
}

```
解决了select中 的两个问题
1. 1024的大小限制
2. fdset不可重用

### epoll
epoll的接口非常简单，一共就三个函数
* epoll_create：创建一个epoll句柄
* epoll_ctl：向 epoll 对象中添加/修改/删除要管理的连接
* epoll_wait：等待其管理的连接上的 IO 事件

### epoll的边缘触发与水平触发
**水平触发(LT)**

关注点是数据是否有无，只要读缓冲区不为空，写缓冲区不满，那么epoll_wait就会一直返回就绪，水平触发是epoll的默认工作方式。

**边缘触发(ET)**

关注点是变化，只要缓冲区的数据有变化，epoll_wait就会返回就绪。
这里的数据变化并不单纯指缓冲区从有数据变为没有数据，或者从没有数据变为有数据，还包括了数据变多或者变少。即当buffer长度有变化时，就会触发。
假设epoll被设置为了边缘触发，当客户端写入了100个字符，由于缓冲区从0变为了100，于是服务端epoll_wait触发一次就绪，服务端读取了2个字节后不再读取。这个时候再去调用epoll_wait会发现不会就绪，只有当客户端再次写入数据后，才会触发就绪。
这就导致如果使用ET模式，那就必须保证要「一次性把数据读取&写入完」，否则会导致数据长期无法读取/写入

### epoll 为什么比select、poll更高效？
* epoll 为什么比select、poll更高效？
* epoll 将文件描述符添加和检测分离，减少了文件描述符拷贝的消耗
  select&poll 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态。下次需要监听时，又需要把之前已经传递过的文件描述符再读传递进去，增加了拷贝文件的无效消耗，当文件描述很多时，性能瓶颈更加明显。
  而epoll只需要使用epoll_ctl添加一次，后续的检查使用epoll_wait，减少了文件拷贝的消耗。

### 总结
select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，
epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O
的实现会负责把数据从内核拷贝到用户空间。

select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间
也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是
select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列
上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。
  




<!--more-->

# mq底层数仓
# runtime包里面的方法
Go 语言的 goroutine 是由 运行时（runtime）调度和管理的  

Go 语言的 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（第 10.8 节）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。

1. Gosched()：让当前线程让出 cpu 以让其它线程运行，它不会挂起当前线程，因此当前线程未来会继续执行。
2. NumCPU()：返回当前系统的 CPU 核数量。
3. GOMAXPROCS()：设置最大的可同时使用的 CPU 核数。 通过runtime.GOMAXPROCS函数，应用程序可以设置运行时系统中的 P 最大数量。注意，如果在运行期间设置该值的话，会引起“Stop the World”。所以，应在应用程序最早期调用，并且最好是在运行Go程序之前设置好操作程序的环境变量GOMAXPROCS，而不是在程序中调用runtime.GOMAXPROCS函数。
4. Goexit()：退出当前 goroutine（但是defer语句会照常执行）。
5. NumGoroutine：返回正在执行和排队的任务总数。
6. runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的 Goroutine 的数量。这里的特定状态是指Grunnable\Gruning\Gsyscall\Gwaition。处于这些状态的Groutine即被看做是活跃的或者说正在被调度。 注意：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。
7. GOOS：查看目标操作系统。很多时候，我们会根据平台的不同实现不同的操作，就可以用GOOS来查看自己所在的操作系统。
8. runtime.GC：会让运行时系统进行一次强制性的垃圾收集。 强制的垃圾回收：不管怎样，都要进行的垃圾回收。非强制的垃圾回收：只会在一定条件下进行的垃圾回收（即运行时，系统自上次垃圾回收之后新申请的堆内存的单元（也成为单元增量）达到指定的数值）。
9. GOROOT() ：获取 goroot 目录。
10. runtime.LockOSThread 和 runtime.UnlockOSThread 函数：前者调用会使调用他的 Goroutine 与当前运行它的M锁定到一起，后者调用会解除这样的锁定。

# redis过期策略和内存淘汰策略
Redis的过期策略和内存淘汰策略是处理内存使用和键过期的重要机制。  
过期策略主要有三种：

1. 定时过期：为每个设置过期时间的键创建一个定时器，当到达过期时间时立即清除该键。这种策略可以立即清除过期的数据，对内存友好，但会占用大量CPU资源，可能影响缓存的响应时间和吞吐量。
2. 惰性过期：只有在访问一个键时，才会判断该键是否已过期，如果过期则清除。这种策略可以最大化地节省CPU资源，但对内存不太友好。在极端情况下，可能会出现大量过期键没有被再次访问，从而不会被清除，占用大量内存。
3. 定期过期：每隔一定的时间，扫描一定数量的键，并清除其中已过期的键。这种策略是前两者的折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
内存淘汰策略在Redis中也很重要，当内存使用超过配置的时候，Redis会采用以下策略之一：

1. noeviction：当内存使用超过配置的时候返回错误，不删除任何键（默认策略）。
2. allkeys-lru：通过LRU（最近最少使用）算法删除最久没有使用的键。
3. volatile-lru：从设置了过期时间的键集合中删除最久没有使用的键。
4. allkeys-random：从所有键中随机删除。
5. volatile-random：从过期键集合中随机删除。
6. volatile-ttl：从配置了过期时间的键中删除过期时间最近的键。
7. volatile-lfu：从所有配置了过期时间的键中删除使用频率最少的键。
8. allkeys-lfu：从所有键中删除使用频率最少的键。
这些策略可以帮助Redis在内存压力较大时，根据一定的规则自动删除一些键，从而释放内存空间。选择合适的策略需要根据具体的应用场景和需求来决定。

# sql索引优化问题
SQL索引优化是数据库性能调优的关键部分。正确的索引策略可以显著提高查询性能，而错误的索引可能会导致性能下降，甚至在某些情况下导致数据库锁争用和其他问题。  

## 何时应该创建索引？
* 当经常根据某个列或列的组合进行查询时。
* 当某个列在WHERE子句、JOIN操作或ORDER BY子句中频繁使用时。
* 当表中的数据量很大，且查询需要扫描大量行时。

## 何时应该避免创建索引？
* 当表的行数很少时。
* 当某个列的值几乎相同或非常稀疏时（即大多数行的该列值都是NULL）。
* 当需要频繁更新的列，因为索引维护会带来性能开销。

## 如何选择索引列？
* 选择经常出现在WHERE子句中的列。
* 选择在ORDER BY和GROUP BY子句中使用的列。
* 选择作为连接条件的列，特别是在JOIN操作中。
* 考虑使用复合索引来覆盖多个查询条件。

## 如何维护索引？
* 定期检查索引的使用情况，并根据实际情况进行调整。
* 使用数据库管理系统的工具和查询来查看索引的效率，例如EXPLAIN计划。
* 定期重建或重新组织索引以消除碎片化，保持其性能。

## mysql索引种类

| 从逻辑功能划分 | 从物理实现划分 | 从作用字段划分 |
|---------|---------|---------|
| 普通索引、唯一索引、主键索引、全文索引        |  聚簇索引、非聚簇索引       |     单列索引、联合索引    |



# 一个update语句的执行过程
1. 解析（Parsing）：

客户端（如 SQL 客户端工具）将 UPDATE 语句发送给 MySQL 服务器。
服务器首先解析 SQL 语句，检查语法是否正确，并确定要执行的操作。
2. 预处理（Preprocessing）：

MySQL 检查语句中涉及的表和列是否存在，以及用户是否有足够的权限执行此操作。
如果语句中使用了任何存储过程或函数，它们在这个阶段也会被处理。
3. 优化（Optimization）：

MySQL 优化器（Optimizer）确定执行该 UPDATE 语句的最佳方法。
优化器可能会考虑多种执行计划，并选择其中一个认为是最有效的。
例如，如果 UPDATE 语句涉及多个索引，优化器可能会选择使用哪个索引来最快地找到需要更新的行。
4. 执行（Execution）：

一旦确定了执行计划，MySQL 开始执行 UPDATE 语句。
它首先定位到需要更新的行，然后根据 SET 子句中的值来更新这些行。
在这个过程中，MySQL 可能会锁定涉及的行或表，以防止其他事务同时修改这些数据。
5. 写回（Write-back）：

如果更新操作导致了数据页的变化，MySQL 会将这些变化写回到磁盘上。
这个过程可能涉及日志记录（例如，在 InnoDB 存储引擎中，可能会写入重做日志和/或撤销日志）。
6. 提交（Commit）：

如果该操作是在事务中执行的，那么在执行完 UPDATE 语句后，事务需要被提交。
提交操作会确保所有之前的更改都被永久保存，并且对其他事务可见。
如果在提交过程中出现错误，MySQL 可能会执行回滚操作，撤销之前所做的更改。


# go的profile工具？
## 有哪几种采样方式
* runtime/pprof：采集程序（非 Server）的指定区块的运行数据进行分析。
* net/http/pprof：基于 HTTP Server 运行，并且可以采集运行时数据进行分析。
* go test：通过运行测试用例，并指定所需标识来进行采集。
* gops: 针对非HTTP Server的其它Server 比如GRPC Server 持续采集


## 支持什么使用模式
* Report generation：报告生成。
* Interactive terminal use：交互式终端使用。
* Web interface：Web 界面。
* graphviz 图形化采集结果


## 可以做什么
* CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。
* Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。
* Block Profiling：阻塞分析，记录 Goroutine 阻塞等待同步（包括定时器通道）的位置，默认不开启，需要调用 runtime.SetBlockProfileRate 进行设置。
* Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况，默认不开启，需要调用 runtime.SetMutexProfileFraction 进行设置。
* Goroutine Profiling： Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。这项功能在实际排查中会经常用到，
  因为很多问题出现时的表象就是 Goroutine 暴增，而这时候我们要做的事情之一就是查看应用程序中的 Goroutine 正在做什么事情，因为什么阻塞了，然后再进行下一步。



# http和tcp有什么区别
1. 性质：HTTP是一个简单的请求-响应协议，主要基于文本进行传输，通常运行在TCP之上。而TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，主要负责数据的可靠传输。
2. 连接：TCP连接是不同但互连的计算机通信网络的主计算机中的成对进程之间的连接，它提供可靠的通信服务。而HTTP通常运行在TCP之上，指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。
3. 功能：当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流时，TCP会将数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。而HTTP协议是基于请求/响应范式的，用于传输超文本或其他内容。
4. 位置：HTTP协议对应于应用层，而TCP协议对应于传输层。从本质上来说，HTTP协议是建立在TCP协议基础之上的。



# 用netstat看tcp连接的时候有关注过time_wait和close_wait吗？
**time_wait**  
time_wait状态表示一个TCP连接在主动关闭之后等待一段时间，以确保最后一个网络分组（可能是之前连接中的最后一个ACK或其他分组）能够安全地到达对方。这是TCP协议设计中的一个重要部分，以避免因延迟的分组导致的新连接与旧连接之间的混淆。在time_wait状态下，连接不会立即关闭，而是会等待一个特定的时间（通常是2倍的MSL，Maximum Segment Lifetime，最大报文段生存时间），以确保所有的分组都已到达对方。

**close_wait**  
close_wait状态表示远程关闭了TCP连接，但本地应用程序还没有关闭套接字。换句话说，这是一个半开状态，其中一方已经决定结束连接，但另一方还没有响应。这通常是由于本地应用程序未能正确处理远程关闭的连接，或者由于应用程序的bug导致的。如果发现有大量的连接处于close_wait状态，这可能是一个性能问题或应用程序错误的指示，需要进一步调查。

# 如何处理
* 对于time_wait，通常不需要手动干预，因为它是TCP协议的正常部分。但是，如果服务器上有大量的time_wait连接，可能会耗尽可用端口，这时可以考虑调整TCP参数，如tcp_fin_timeout，或者使用SO_REUSEADDR套接字选项。
* 对于close_wait，应该检查应用程序的代码和逻辑，确保在接收到远程关闭连接的通知时，本地也正确地关闭了连接。此外，定期清理和监控处于close_wait状态的连接也是很有帮助的。

>  netstat -natp 查看网络连接情况

# fork的底层实现方式
fork() 是一个 Unix/Linux 系统调用，它创建一个与当前进程几乎完全相同的子进程。新创建的子进程（子进程）获得与父进程（调用 fork() 的进程）几乎完全相同的环境：相同的程序，相同的开放文件和环境变量等。子进程和父进程之间的主要区别在于它们的 PID（进程 ID）和 PPID（父进程 ID），以及某些状态和资源使用情况（如未处理的信号和文件锁）。

fork() 的底层实现方式主要依赖于操作系统内核，特别是其进程管理和内存管理部分。以下是一个简化的 fork() 实现概述：  
1. 复制进程描述符
* 当一个进程调用 fork() 时，内核首先为新的子进程创建一个新的进程描述符（也称为任务结构或进程控制块）。
* 这个新的进程描述符是父进程描述符的一个副本，但大多数字段（如 PID 和 PPID）都需要修改。

2. 复制或共享内存
* 写时复制 (Copy-on-Write, CoW) 这是大多数现代 Unix/Linux 系统使用的策略。在 fork() 时，子进程并不立即获得父进程的物理内存页的副本。相反，它们共享相同的物理内存页，但每个页面都有一个额外的引用计数器。当任何一个进程尝试修改一个页面时，内核会为该页面创建一个新的副本，并更新相应的引用计数器。这样可以节省内存，因为许多进程在创建后很快就执行 exec() 系列调用，替换了它们的内存内容。
* 完全复制：在某些情况下，或者在某些操作系统版本中，子进程会立即获得父进程内存空间的完整副本。这会增加 fork() 的开销，但确保子进程和父进程在 fork() 后有完全独立的内存空间。

3. 复制其他资源
* 除了内存外，还需要复制其他进程资源，如打开的文件描述符、信号处理程序、信号屏蔽字、账户信息、进程调度信息等。
* 在许多情况下，子进程和父进程会共享某些资源，如文件描述符（使用写时复制策略）。

4. 设置子进程的上下文
* 子进程需要有自己的上下文，包括其自己的寄存器状态、栈和程序计数器。这通常是通过复制父进程的上下文并稍作修改来实现的。
* 在某些情况下，子进程可能会立即执行一个新的程序（通过 exec() 系列调用），因此不需要保留父进程的上下文。

5. 返回
fork() 在父进程中返回子进程的 PID，在子进程中返回 0。这样，父进程和子进程就可以根据它们的返回值来区分自己的身份，并执行相应的操作。


# go语言什么时候垃圾回收，写代码的时候如何减少小对象分配
## go垃圾回收GC触发条件
1. 超过内存大小阈值
2. 达到定时时间

阈值是由一个gcpercent的变量控制的,当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。

## 减少小对象分配
1. 使用对象池
2. 结构体复用 如果你的程序中频繁地创建和销毁具有相同字段的结构体对象，可以考虑使用切片（slice）或映射（map）来存储这些对象，并在需要时重用它们。通过避免频繁地分配和释放内存，可以减少垃圾回收的压力。
3. 使用更大的数据结构 如果频繁分配的小对象可以组合成更大的数据结构，那么使用这些更大的数据结构可能会更有效。例如，使用切片（slice）代替单独的对象，或者使用映射（map）代替独立的键值对。



## redis的存储结构？
1. 字符串
2. 哈希表
3. 列表
4. 集合
5. 有序集合
6. 地理位置（Geo）
7. 基数统计（HyperLogLog）
8. 位图（Bitmaps）

# 实现map的方法除了哈希还有哪些？
哈希表，散列表（Scatter Table）：散列表是另一种用于实现映射的数据结构，它通过哈希函数将键映射到散列表中的槽位。每个槽位存储一个值或一个指向值的指针。当发生哈希冲突时，可以使用链地址法、开放地址法等策略进行处理。


1. 二叉搜索树（Binary Search Tree）：二叉搜索树是一种常用的数据结构，它可以用来实现映射。在二叉搜索树中，每个节点都包含一个键和一个值，树的左子树包含所有键小于当前节点键的节点，右子树包含所有键大于当前节点键的节点。通过遍历二叉搜索树，我们可以找到特定的键并返回对应的值。
2. 平衡二叉搜索树（Balanced Binary Search Tree）：平衡二叉搜索树是二叉搜索树的改进版本，它通过维护树的平衡性来确保查找、插入和删除操作的效率。常见的平衡二叉搜索树有AVL树、红黑树等。
3. B树（B-Tree）：B树是一种自平衡的树，主要用于维护排序数据的有序性。B树的阶（order）定义了每个节点允许的最大子节点数目。B树在数据库和文件系统中广泛应用，也可以用来实现映射。
4. B+树（B+-Tree）：B+树是B树的变种，它在B树的基础上进行了优化。B+树的叶子节点之间通过指针相连，形成了一个有序链表，这使得范围查询和顺序访问变得更加高效。B+树在数据库索引中广泛使用。
5. Trie树（前缀树）：Trie树是一种用于存储字符串集合的树形数据结构。在Trie树中，每个节点表示一个字符，从根节点到某个节点的路径表示一个字符串。Trie树非常适合用于实现基于字符串键的映射。


redis的setnx底层怎么实现的？
go的gc原理了解吗？
gin框架的路由是怎么处理的？
mysql索引结构
B+树和B树有什么区别
sql查询性能瓶颈处理方式
sql索引优化方式，explain字段含义
gmp具体的调度策略
B+树细节优势，和哈希索引的区别，是为了解决什么问题？
事务四个特性四个隔离级别
httptime_wait状态分析
nginx负载均衡策略
es内部实现原理，如何保证数据一致性，如何降低压力
linux查看磁盘、io、内存情况的命令
分库分表联表查询有哪些方式
覆盖查询&回表查询
聚簇索引&非聚簇索引
go实现不重启热部署
go性能分析工具
tcp如何保证稳定性
http和http2区别
https的连接过程
kafka如何做到高可用
分布式锁如何实现
读扩散&写扩散
goroutine创建数量有限制吗？
go并发机制
线程协程区别
锁的可重入
常用限流算法
rpc调用过程
熔断降级开源框架
serviceMash
什么操作会影响联表查询效率
一个sql的查询过程
redis单线程是如何做到支持高并发的
IO多路复用
为什么内存操作很快
innoDB为什么支持事务
内存操作为什么很快
go内存操作也要处理IO，是如何处理的?
k8s各种组件
gomap并发安全问题，如何解决
gogc
一个进程能创建的线程数量受到哪些制约？
redis主从同步怎么做的
k8s组件及其作用
k8s基本操作
docker底层实现原理
docker基本操作
linux常用操作
linux内核
集群分布式
线程
etcd
grpc
kafka
es
数据库分库分表，啥时候分库啥时候分表
数据库的存储引擎有哪些，区别是啥
innodb索引用的是啥，为什么不用b+、红黑
事务的隔离级别
层序遍历二叉树
判断二叉树是否是镜像二叉树
堆排
中间件:kafka丢失消息和不重复消费
redis底层数据结构实现
mysql索引，mongodb和mysql索引的区别，给了条sql语句问索引怎么构建
golang:切片和数组、map、gc、gpm调度模型
高并发限流、熔断
对一个链表进行排序
mysql引擎知道哪些，有哪些索引，底层是怎么实现的
redis底层实现
给n个数1n，随机n次，将这n个数输出
线程和协程的区别
io多路复用，select\poll\epoll的实现和区别
三次握手和四次挥手
长连接和短链接(怎么实现的、区别以及应用场景)
计算二叉树所有左叶子节点的和
n对括号输出所有合法的情况
n个有序的数组合并成一个
GPM调度模型
协程和线程的区别，内核态和用户态
btree和b+tree
二叉树中序遍历，递归和非递归两种方式
kafka如何保证消息有序，消息的重复和丢失
http和https的区别，https建立连接的过程
http1.1和http2.0的区别
缓存和数据库一致性的问题
syncpool的实现原理
hash冲突解决办法，有什么弊端
map里面解决hash冲突怎么做的，冲突了元素放在头还是尾
10亿的url去重怎么做
rediszset怎么使用的，底层怎么实现的，适用于什么场景
单链表找到中间节点
设计一个秒杀系统
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针
while(tree){sleep(1)}这个会有什么问题
sleep底层实现原理
线上问题一般怎么排查，比如oom
手写LRU相关知识点：模拟，结构，增删改查
一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值
docker和虚拟机区别
k8s底层原理
linux文件系统
网络七层模型和五层模型
数据库索引
MySQL优化（索引、分表分库）
最左匹配原则？问为什么有这个东西？
同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题
channel和锁对比一下
channel的应用场景
slice和array区别
向为nil的channel发送数据会怎么样
map取一个key，然后修改这个值，原map数据的值会不会变化
Hash实现、冲突解决、应用
输入URL发生的整个网络过程
Redis怎么保证数据一致性
TCP流量控制、拥塞控制
TCP半连接队列
TCP半关闭状态
TCPTIME_WAIT状态
内核态、用户态
100枚硬币，其中有一枚硬币重量不一样，用天平秤怎么快速找到这一枚硬币
LRU缓存实现，要求set\get操作o(1)时间复杂度
TCP滑动窗口
一个SQL语句的执行过程
MVCC原理
ACID的涵义，MYSQL是如何保证的
缓存失效的几种场景，以及解决方案
缓存雪崩、击穿的解决方案
如何排查线上程序问题
protobuf为什么快
分布式系统优缺点，一致性是如何保证的
雪崩、穿透和击穿
最终一致性
mysql分布式id
mysql索引慢分析：线上开启slowlog，提取慢查询，然后仔细分析explain中tye字段以及extra字段，发生的具体场景及mysql是怎么做的
mysql分库分表平滑扩容方案
docker预热
gowaitgroup的坑
k8s原理
mysql隔离级别、sql慢查询
etcd原理
给一个栈，用另外一个栈实现排序
gostruct能不能比较
select可以用于什么
context包的用途
client如何实现长连接
主协程如何等其余协程完再操作
slice，len，cap，共享，扩容
map如何顺序读取
大文件排序
数据库如何建索引
tcp与udp区别，udp优点，适用场景
raft算法是那种一致性算法
一个请求到达pod的过程、configmap、dockerfile
二叉树遍历，非递归