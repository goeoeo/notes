---
categories: 
- redis
tags:
- redis面试题
---


## 使用Redis有哪些好处
* 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
* 支持丰富数据类型，支持string，list，set，sorted set，hash
* 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
* 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
<!--more-->

## redis相比memcached有哪些优势
* memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
* redis的速度比memcached快很多
* redis可以持久化其数据

## redis常见性能问题和解决方案
### Master写内存快照
save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。 
 
Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。  
### Master AOF持久化
如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。

如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。
### Master调用BGREWRITEAOF
Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。
  
将no-appendfsync-on-rewrite的配置设为yes可以缓解这个问题，设置为yes表示rewrite期间对新写操作不fsync，暂时存在内存中，等rewrite完成后再写入。最好是不开启Master的AOF备份功能。  
#### Redis主从复制的性能问题
第一次Slave向Master同步的实现是：Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的
命令转发给Slave，初次同步完成。第二次以及以后的同步实现是：Master将变量的快照直接实时依次发送给各个Slave。不管什么原因导致Slave和
Master断开重连都会重复以上过程。Redis的主从复制是建立在内存快照的持久化基础上，只要有Slave就一定会有内存快照发生。虽然Redis宣称主从
复制无阻塞，但由于Redis使用单线程服务，如果Master快照文件比较大，那么第一次全量传输会耗费比较长时间，且文件传输过程中Master可能无法
提供服务，也就是说服务会中断，对于关键服务，这个后果也是很可怕的。  

尽量避免在压力较大的主库上增加从库。

### 单点故障问题
由于目前Redis的主从复制还不够成熟，所以存在明显的单点故障问题，这个目前只能自己做方案解决

为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master<–Slave1<–Slave2<–Slave3…….，这样的结构也方便解
决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。

## MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
### 相关知识  
redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 
### 6种数据淘汰策略  
* volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
* volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰
* volatile-random 从已设置过期时间的数据集中任意选择数据淘汰
* allkeys-lru 从数据集中挑选最近最少使用的数据淘汰
* allkeys-random 从数据集中任意选择数据淘汰
* no-enviction 禁止驱逐数据
### 实际操作  
计算一下20w数据大约占用的内存，设置Redis内存限制，设置淘汰策略，加载热数据到内存中

## Memcache与Redis的区别都有哪些  
### 存储方式  
* Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小
* Redis有部份存在硬盘上，这样能保证数据的持久性。
### 数据支持类型  
* Memcache对数据类型支持相对简单
* Redis有复杂的数据类型
### value大小  
* redis最大可以达到1GB，而memcache只有1MB

## redis最适合的场景
### 缓存  
缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，
也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。
### 排行榜  
很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。
### 计数器  
什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无
疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。
### 分布式会话  
集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中
心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。
### 分布式锁  
在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可
以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。
可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。
### 社交网络  
点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，
Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。
### 最新列表  
Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。
### 消息系统  
消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。
Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。

## Redis的同步机制
Redis通过主从同步机制来确保master和salve之间的数据同步

### 全量复制
全量复制是指salve启动时进行的初始化同步。  
全同步过程：
1. 在salve启动时，会向master发送一条SYNC指令。  
2. master收到这条指令后，会启动一个备份进程将所有数据写到rdb文件中去。  
3. 更新master的状态（备份是否成功、备份时间等），然后将rdb文件内容发送给等待中的salve。  
> master并不会立即将rdb内容发送给salve。而是为每个等待中的salve注册写事件，当salve对应的socket可以发送数据时，再讲rdb内容发送给salve。
### 增量拷贝
如果出现网络闪断或者命令丢失等异常情况时，当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync
参数发送给主节点，要求进行部分复制操作  
主节点接到psync命令后首先核对参数runId是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找
，如果偏移量之后的数据存在缓冲区中，则对从节点发送+continue响应，表示可以进行部分复制；否则进行全量复制。  
主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。

## 是否使用过Redis集群,集群的原理是什么


## redis集群如何保证一致性


## 数据库与缓存数据一致性问题
Cache Aside Pattern  
1.失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中  
2.命中：程序先从缓存中读取数据，如果命中，则直接返回
3.更新：程序先更新数据库，在删除缓存

如何解决缓存击穿问题？  
当一个线程需要去访问这个缓存的时候，如果发现缓存为空，则需要先去竞争一个锁，如果成功则进行正常的数据库读取和写入缓存这一操作，然后再释放锁，否则就等待一段时间之后，重新尝试读取缓存，如果还没有数据就继续去竞争锁　　

怎么做到强一致性？   
上一致性协议当然是可以的，虽然成本也是非常客观的。2PC甚至是3PC本身是存在一定程度的缺陷的，所以如果要采用这个方案，那么在架构设计中要引入很多的容错，回退和兜底措施。那如果是上Paxos和Raft呢？那么你首先至少要看过这两者的相关论文，并且调研清楚目前市面上有哪些开源方案，并做好充分的验证，并且能够做到出了问题自己有能力修复...对了，我还没提到性能问题呢。

