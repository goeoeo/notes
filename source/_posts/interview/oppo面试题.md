---
title: oppo面试题 
categories: 
- interview
tags:
- 面试题
---

# golang
# redis
## zset底层数据结构
## 跳表和红黑树
## 为什么redis选跳表而不是红黑树
## redis预热，预热会阻塞吗，如何处理，如果有重复数据预热，如何处理

<!--more-->
# mongo
# mysql
## 索引类型
## 索引优化
## 查询优化(慢SQL优化)
## 事务ACID
## 事务隔离机制
## MVCC机制
## B+树与B树
## undo log, binlog, redo log的作用是什么
## 主从复制


# 架构
## 高并发
* 横向扩容（加服务器）读多写少
* 加缓存 读多写少
* 引入ES 读多写少
* 分库分表 读多写多
  * 服务性性能不够用，分库
  * 数据量大，数据库锁瓶颈的时候，分表
* MQ消峰 写多
  * 请求来了直接往mq扔
  * 完成主线任务，支线任务异步处理
* 微服务

## 高可用
* 故障转移，多节点服务
* 服务限流，熔断，降级，避免大流量把服务打挂
* 灰度发布

## 秒杀库存扣减

# Linux

## IO多路复用

# 网络协议
## HTTP

## TCP
### 三次握手
### 四川挥手
### TCP粘包
1. 定长消息（ftp）
2. 分割符（smtp）
3. TLV, type length value (http1.1,websocket,protobuf,thrift)
### 流量控制和网络拥塞控制


## RPC

### RPC框架如何实现

# 数据结构和算法

# 消息中间件

## rabbitmq
# 设计模式
创建型模式：  
1. 单例模式（Singleton）：确保一个类仅有一个实例，并提供一个全局访问点。
2. 工厂模式（Factory）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
3. 抽象工厂模式（Abstract Factory）：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
4. 建造者模式（Builder）：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
5. 原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

结构型模式：  
1. 适配器模式（Adapter）：将一个类的接口转换成客户期望的另一个接口。适配器让原本由于接口不兼容而无法协同工作的类可以一起工作。
2. 桥接模式（Bridge）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
3. 组合模式（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
4. 装饰器模式（Decorator）：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
5. 外观模式（Facade）：为子系统中的一组接口提供了一个统一的高层接口，使得子系统更容易使用。
6. 享元模式（Flyweight）：运用共享技术有效地支持大量细粒度的对象。

行为型模式：  
1. 模板方法模式（Template Method）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
2. 策略模式（Strategy）：定义了一系列的算法，并将每一个算法封装起来，使它们可以互相替换。策略模式使得算法可以独立于使用它的客户变化。
3. 状态模式（State）：允许一个对象在其内部状态改变时改变它的行为。对象看起来好像修改了它的类。
4. 观察者模式（Observer）：定义对象之间的一对多依赖关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
5. 迭代器模式（Iterator）：它提供一种方法访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
6. 中介者模式（Mediator）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
7. 解释器模式（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
8. 职责链模式（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
9. 备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
10. 访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。